# Java面向对象

## ==/equals区别？

1. 对象类型不同

* equals()：是超类Object中的方法。 
* ==：是操作符。

2. 比较的对象不同

* equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。 
* ==：用于比较引用和比较基本数据类型时具有不同的功能

3. 运行速度不同

* equals()：没有==运行速度快。 
* ==：运行速度比equals()快，因为==只是比较引用。

## **深拷贝/浅拷贝的区别？**

* 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。
* 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。

## 接口和抽象类有什么区别/联系？

* Interface(接口):定义功能，只能包含方法(实现),不能包含成员变量，可以被实现若干次。 
* Abstract class(抽象类):定义抽象的骨架实现，可以包含抽象方法或者实现，也可以包含成员变量，只能沿着一条路径继承。

## 什么时候用接口/抽象类？

1. 如果预计要创建组件的多个版本，则创建`抽象类`。抽象类提供简单的方法来控制组件版本； 
2. 如果创建的功能将在大范围的全异对象间使用，则使用`接口`。如果要设计小而简练的功能块，则使用接口； 
3. 如果要设计大的功能单元，则使用`抽象类`。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类； 
4. `抽象类`主要用于关系密切的对象；而`接口`适合为不相关的类提供通用功能。

## final的作用？

在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。

1. 修饰类

当用final修饰一个类时，表明这个类不能被继承。

2. 修饰方法

如果只有在想明确禁止,该方法在子类中被覆盖的情况下才将方法设置为final的。
* 即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。

3. 修饰变量

* final成员变量表示常量，只能被赋值一次，赋值后值不再改变。
* 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；
* 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。
* final修饰一个成员变量（属性），必须要显示初始化。
* 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。

## @override和@overload的作用？

* `override`是重写,重写是一种动态绑定的多态机制。
* `overload`是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的多态机制。

`@Override`是伪代码,表示`重写`(当然不写也可以)，不过写上有如下好处:

1. 可以当注释用,方便阅读； 
2. 编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。

![比较](/img/Java面向对象/1.png)


