<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>面试技巧 - 分类 - 哈哈博客</title>
        <link>https://hahaen.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
        <description>面试技巧 - 分类 - 哈哈博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>630606938@qq.com (hahaen)</managingEditor>
            <webMaster>630606938@qq.com (hahaen)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 10 Mar 2022 20:11:57 &#43;0800</lastBuildDate><atom:link href="https://hahaen.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" rel="self" type="application/rss+xml" /><item>
    <title>重写和重载的作用？</title>
    <link>https://hahaen.github.io/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
    <pubDate>Thu, 10 Mar 2022 20:11:57 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
    <description><![CDATA[override是重写,重写是一种动态绑定的多态机制。 overload是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的]]></description>
</item><item>
    <title>为什么重写equals时必须重写hashCode方法？</title>
    <link>https://hahaen.github.io/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/</link>
    <pubDate>Thu, 10 Mar 2022 19:27:38 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/</guid>
    <description><![CDATA[因为两个相等的对象的hashCode值必须是相等。 也就是说如果equals方法判断两个对象是相等的，那这两个对象的hashCode值也要相等]]></description>
</item><item>
    <title>静态方法和实例方法有何不同？</title>
    <link>https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/</link>
    <pubDate>Thu, 10 Mar 2022 17:30:12 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/</guid>
    <description><![CDATA[调用方式 在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象.方法名的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可]]></description>
</item><item>
    <title>静态方法为什么不能调用非静态方法？</title>
    <link>https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</link>
    <pubDate>Thu, 10 Mar 2022 17:27:37 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</guid>
    <description><![CDATA[静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例]]></description>
</item><item>
    <title>Continue、break和return的区别是什么？</title>
    <link>https://hahaen.github.io/continuebreak%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</link>
    <pubDate>Thu, 10 Mar 2022 17:14:47 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/continuebreak%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
    <description><![CDATA[在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。 但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环]]></description>
</item><item>
    <title>自增运算符&#43;&#43;和自减运算符  </title>
    <link>https://hahaen.github.io/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
    <pubDate>Thu, 10 Mar 2022 17:10:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
    <description><![CDATA[++ 和 &ndash; 运算符可以放在变量之前，也可以放在变量之后 当运算符放在变量之前时(前缀)，先自增/减，再赋值 ++a 当运算符放在变量之后时(后缀)，先赋值，]]></description>
</item><item>
    <title>Java异常</title>
    <link>https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/</link>
    <pubDate>Thu, 10 Mar 2022 16:58:49 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/</guid>
    <description><![CDATA[异常基本类型 异常类的基本类型是Throwable类 两大子类分别是Error和Exception Error 系统错误由Java虚拟机抛出，用Error类]]></description>
</item><item>
    <title>Final的作用？</title>
    <link>https://hahaen.github.io/final%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
    <pubDate>Thu, 10 Mar 2022 16:52:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/final%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
    <description><![CDATA[在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类 当用final修饰一个类时，表明这个类不能被继承。]]></description>
</item><item>
    <title>什么时候用接口或抽象类？</title>
    <link>https://hahaen.github.io/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%88%96%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
    <pubDate>Thu, 10 Mar 2022 16:52:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%88%96%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
    <description><![CDATA[如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本； 如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要]]></description>
</item><item>
    <title>接口和抽象类有什么区别or联系？</title>
    <link>https://hahaen.github.io/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%ABor%E8%81%94%E7%B3%BB/</link>
    <pubDate>Thu, 10 Mar 2022 16:49:45 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://hahaen.github.io/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%ABor%E8%81%94%E7%B3%BB/</guid>
    <description><![CDATA[Interface(接口):定义功能，只能包含方法(实现),不能包含成员变量，可以被实现若干次。 Abstract class(抽象类):定义抽象的骨架实现，]]></description>
</item></channel>
</rss>
