[{"categories":["各种问题"],"content":"idea版本2021.2.1 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:0","tags":["问题"],"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["各种问题"],"content":"连接mysql报错 删除这三个就测试成功 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":["问题"],"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["各种问题"],"content":"例： docker run --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:5.7.27 docker run --name=mediawiki_mysql \\ -e MYSQL_DATABASE=wikidb \\ -e MYSQL_USER=wikiuser \\ -e MYSQL_PASSWORD=mysecret \\ -e MYSQL_ROOT_PASSWORD=zhang123 \\ -v /var/mediawiki/mysql:/var/lib/mysql \\ -d mysql:5.7.27 上面命令中的 \\ 是换行 -d 是指定镜像，本地没有的话会从docker服务器下载 -p 映射容器的3306到本地3306，前面是本地端口，-p 3306:3306 这里已经设置了一组管理数据库的用户名:wikiuser 密码:mysecret 通常使用-e MYSQL_RANDOM_ROOT_PASSWORD=1 把root设置为随机，只使用wikiuser用户来管理 -v 是映射本地目录到容器，目录需要提前创建，或者sudo chmod 777 /var/mediawiki，启动容器会自己创建mysql目录 进入容器： docker exec -it [容器名或容器ID] bash ","date":"2021-11-02","objectID":"https://hahaen.github.io/docker-run-mysql%E6%98%A0%E5%B0%84/:0:0","tags":["问题"],"title":"Docker Run Mysql映射","uri":"https://hahaen.github.io/docker-run-mysql%E6%98%A0%E5%B0%84/"},{"categories":["java知识"],"content":"正则表达式在线测试 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"基本用法 常用的元字符 ^ 开始位置 $ 结束位置 . 单个任意字符（不⼀一定包含换⾏行行符 \\w 单个“word”字符字母/数字/下划线/汉字 \\s 单个空白字符（\\n\\r\\t） \\d 单个数字字符 \\b 单词的开始或结束 重复 * 0次或多次 + 1次或多次 ？ 0次或1次 {n} n次 {n,} \u003e=n次 {n,m} n到m次 选择 [aeiou] 单个的a/e/i/o/u字符之⼀一 [0-9] 单个数字字符 [A-Z] 单个大写字母 [A-Z0-9] 大写字母或者数字或者下划线 Hi|hi 等价于 [Hh]i Hi或者hi 反义 [^aeiou] 单个的除a/e/i/o/u之外的字符 [^A] 单个非x字符 \\W 单个非\\w（字⺟母/数字/下划线/汉字） \\S 单个非\\s（空白) \\D 单个非\\d（数字）字符 \\B 非开头/结束位置 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中的正则表达式 String split() replaceAll/replaceFirst matches 效率低 尽量少用、少编译 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"分组与捕获 左括号( –开始数 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中处理捕获 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["html"],"content":"URL 英文：Uniform Resource Locator https://zh.wikipedia.org:443/w/index.php?title=随机页面 https，是协议； zh.wikipedia.org，是服务器； 443，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:随机页面，是询问。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:1:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"DNS 英文：Domain Name System ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"作用： 根据域名查出IP地址 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:1","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"nslookup 命令 用于互动式地查询域名记录 进入交互模式，总共有两种方法。 第一种方法，直接输入 nslookup 命令，不加任何参数，则直接进入交互模式，此时 nslookup 会连接到默认的域名服务器（即 /etc/resolv.conf 的第一个 dns 地址）。 第二种方法，是支持选定不同域名服务器的。需要设置第一个参数为“-”，然后第二个参数是设置要连接的域名服务器主机名或 IP 地址。 如果你直接在 nslookup 命令后加上所要查询的 IP 或主机名，那么就进入了非交互模式。当然，也可以在第二个参数位置设置所要连接的域名服务器。 例子 交互模式下查询域名 nslookup \u003e www.douban.com Server: 127.0.1.1 // 往上连接的 DNS 服务器 Address: 127.0.1.1#53 // DNS 服务器 IP 地址与端口 Non-authoritative answer: // 非权威答案，从上连 DNS 服务器本地缓存中读取，非实际查询得到 Name: www.douban.com Address: 115.182.201.6 // IP 地址 Name: www.douban.com Address: 115.182.201.7 Name: www.douban.com Address: 115.182.201.8 交互模式下更改 DNS 进入交互模式之后，使用 server dns-server 来改变上连 DNS 服务器地址 查询域名 ip 地址 nslookup www.douban.com [dns-server] //如果没有指定 dns-server，使用系统默认的 DNS 服务器。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:2","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"IP ip138-查询本机ip ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"IP地址： 互联网协议地址 IP地址是人们在Internet上为了区分数以亿计的主机而给每台主机分配的一个专门的地址，通过IP地址就可以访问到每一台主机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:1","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"ping 命令 Ping 命令详解 输入ping /? ，列出ping的相关参数 用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name -t ：Ping 指定的计算机直到中断。 -a ：将地址解析为计算机名。 -n count ：发送 count 指定的 ECHO 数据包数。默认值为 4。 -l size ：发送包含由 size 指定的数据量的 ECHO 数据包。默认为 32 字节；最大值是65,527。 -f ：在数据包中发送\"不要分段\"标志。数据包就不会被路由上的网关分段。 -i ttl :将\"生存时间\"字段设置为 ttl 指定的值。 -v tos :将\"服务类型\"字段设置为 tos 指定的值。 -r count :在\"记录路由\"字段中记录传出和返回数据包的路由。count 可以指定最少 1 台，最多 9 台计算机。 -s count :指定 count 指定的跃点数的时间戳。 -j host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机可以被中间网关分隔（路由稀疏源）IP 允许的最大数量为 9。 -k host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机不能被中间网关分隔（路由严格源）IP 允许的最大数量为 9。 -w timeout :指定超时间隔，单位为毫秒。 destination-list :指定要 ping 的远程计算机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:2","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"域名 域名-维基百科 域名是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。 www.xiedaimala.com和xiedaimala.com 不是同一域名 com是顶级域名 xiedaimala.com是二级域名(俗称一级域名) www.xiedaimala.com是三级域名(俗称二级) 上面的两是父子关系 例如 github. io把子域名 XXX.github.io免费给你使用 所以www.xiedaimala.com和xiedaimala. com可以不是同一家公司,也可以是 www是多余的,非常多余。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:4:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"搜索技巧： 谷歌搜索 mdn + xx(标签) ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"a 标签的用法 ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"href \u003cul\u003e \u003cli\u003e\u003ca href=\"http://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"https://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"//baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/a/b/index.html\"\u003e/a/b/index.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"./index.html\"\u003eindex.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789@163.com\"\u003eEmail\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789\"\u003ePhone\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e 注意: 可以使用 href=\"#top\" 或者 href=\"#\" 链接返回到页面顶部。 ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:1","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"target _self: 当前页面加载。此值是默认的，如果没有指定属性的话。 _blank: 新窗口打开。 _parent: 加载响应到当前的浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式与 _self 相同。 _top: IHTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:2","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 a ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:3","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"img 标签的用法 \u003cimg class=\"fit-picture\" src=\"1.jpg\" alt=\"网络错误\"\u003e src 属性是必须的，它包含了你想嵌入的图片的文件路径。 alt 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。 img ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"table 标签的用法 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eThe table header\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eThe table body\u003c/td\u003e \u003ctd\u003ewith two columns\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e table ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["爬虫项目实战"],"content":"Java多线程原理 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"为什么需要多线程？ 可以提高程序的执行性能 例如：一个人洗菜做法，和多个人一起洗菜做饭效率不一样。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"多线程带来了什么问题，如何避免？ 线程安全问题 例如：银行存钱取件需要完整，不可出现错误。 保证线程安全需要满足两大条件： 原子性：一系列操作，要么全部完成，要么全部不完成，不可被分割，不会结束在中间某个环节。 可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 上下文切换 线程与 CPU 单核执行是一对一的 CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行，在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态 线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用 这就是当我们开启大量线程，系统反而更慢 解决办法 减少锁等待 使用合适的线程数 CAS 算法 死锁 线程 A 和线程 B 都拥有一份锁，而线程 A 和线程 B 恰好同时去获取对方拥有的那把锁， 导致两个线程永远无法执行， 要避免死锁有一个方法即获取锁的顺序是固定的， 比如只能先获取锁 X 再获取锁 Y，不允许出现相反的顺序。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"线程的属性、状态、生命周期详解 线程可以分为5个状态： New(新建) Runnable（就绪） Running(运行) blocked(被阻塞) Dead(死亡) New(新建) 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 Thread t1=new Thread(); Runnable（就绪） 线程已经被启动，正在等待被分配给CPU时间片， 也就是说此时线程正在就绪队列中排队等候得到CPU资源。 t1.start(); Running(运行) 线程获得CPU资源正在执行任务（run()方法）， 此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入， 线程将一直运行到结束。 blocked(被阻塞) 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） Dead(死亡) 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:3","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"什么是ThreadLocal？ 每个线程自己独有的，不与其它线程共享的变量。 常用的两内部类，四个方法： get()方法是用来获取ThreadLocal在当前线程中保存的变量副本。 set()用来设置当前线程中变量的副本。 remove()用来移除当前线程中变量的副本。 initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:4","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"为什么需要线程池？ 线程池 在Java 5之后，Java通过Executor来启动线程，比使用Thread的start方法更好， 除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题。 简单的说就是把线程统一管理。 线程池优势： 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行； 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。 提供更强大的功能，延时定时线程池。 Java的4种默认线程池 newSingleThreadExecutor 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixeThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:5","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"线程池的构造函数中的参数都是什么含义？ ThreadPollExecutor中的所有的构造函数最终都会调用上面这个构造函数，接下来我们来分析一下这些参数的含义： corePoolSize： 线程池启动后，在池中保持的线程的最小数量。 需要说明的是线程数量是逐步到达corePoolSize值的。 例如corePoolSize被设置为10，而任务数量只有5，则线程池中最多会启动5个线程，而不是一次性地启动10个线程。 maxinumPoolSize： 线程池中能容纳的最大线程数量， 如果超出，则使用RejectedExecutionHandler拒绝策略处理。 keepAliveTime： 线程的最大生命周期。这里的生命周期有两个约束条件： 一：该参数针对的是超过corePoolSize数量的线程； 二：处于非运行状态的线程。 例：如果corePoolSize（最小线程数）为10，maxinumPoolSize（最大线程数）为20，而此时线程池中有15个线程在运行，过了一段时间后，其中有3个线程处于等待状态的时间超过keepAliveTime指定的时间，则结束这3个线程，此时线程池中则还有12个线程正在运行。 unit： 这是keepAliveTime的时间单位 可以是纳秒，毫秒，秒，分钟等。 workQueue： 任务队列。 当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。 这个任务队列是一个阻塞式的单端队列。 newFixedThreadPool和newSingleThreadExector使用的是LinkedBlockingQueue的无界模式。 threadFactory： 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。 handler： 拒绝任务处理器。 由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。 线程的管理过程： 首先创建一个线程池， 然后根据任务的数量逐步将线程增大到corePoolSize， 如果此时仍有任务增加，则放置到workQueue中，直到workQueue爆满为止， 然后继续增加池中的线程数量（增强处理能力），最终达到maxinumPoolSize。 那如果此时还有任务要增加进来，需要handler来处理， 或者丢弃新任务，或者拒绝新任务，或者挤占已有的任务。 在任务队列和线程池都饱和的情况下，一旦有线程处于等待（任务处理完毕，没有新任务）状态的时间超过keepAliveTime，则该线程终止， 也就是说池中的线程数量会逐渐降低，直至为corePoolSize数量为止。 总结 corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程 maximumPoolSize: 线程池维护线程的最大线程数 keepAliveTime: 线程池维护线程所允许的空闲时间 unit: 程池维护线程所允许的空闲时间的单位 workQueue: 线程池所使用的缓冲队列 handler: 线程池对拒绝任务的处理策略 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:6","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"Http方法与状态码 http方法 GET 拿 POST 发送 GET / HTTP/1.1 //GET请求根路径 使用HTTP1.1协议 Host: xiedaimala.com User-Agent: //用户代理（浏览器） 可根据查看相关信息 Http状态码 200请求成功。一般用于GET与POST请求 http猫 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:1:0","tags":["java"],"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["爬虫项目实战"],"content":"HTTP的header与body 重要的header Accept Cookie User-Agent //浏览器标识 Referer //上一个页面是什么 Referer: http://idpeng.xyz/ Content-type //下载或者图片 content-type: text/html; charset=utf-8 Set-Cookie //登录后服务器自动设置的cookie http是无状态的 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:2:0","tags":["java"],"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["爬虫项目实战"],"content":"计算机网络是如何工作的 在打开网页的时候发生了什么 主机 域名与DNS 端⼝:HTTPS协议的默认端⼝口是443，HTTP协议的默认端⼝口是80 TCP协议 HTTP协议 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:1:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"浏览器是如何工作的 在网络上传输的只是字节流 HTTP协议 HTML JavaScript CSS ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:2:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"同步与异步加载 同步加载：同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 异步加载：异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。 服务器端一次返回所有的数据 服务器端返回部分数据，使用AJAX异步加载 区别 异步：在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。 同步：在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:3:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"注意 只要浏览器能做到的 其他代码一定能做到 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:4:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"Collection体系的常用类及其背后的数据结构 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"C0llection常用类 list 有序可重复，拥有下标,最常用的是 ArrayList，实际就是一个数组 常用类： ArrayList LinkedList set 无序且不可重复的元素集合,没有下标。 HashSet（无序） LinkedHashSet（有序） TreeSet（排序） Collection体系简介图 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection背后的数据结构 ArrayList与LinedList Arraylist：底层使用的是Object 数组。 LinkedList：底层使用的是 双向链表 数据结构。 HashSet、LinkedHashSet与TreeSet HashSet: 底层采用 HashMap 来保存元素，HashMap 使用的是拉链法，也叫作链地址法。 LinkedHashSet：底层是链表+哈希表，链表保证数据存储有序，链表用来记录存储顺序；哈希表保证数据唯一，存储真正的数据 TreeSet：红黑树 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList源码阅读 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"继承结构 ArrayList extends AbstractList AbstractList extends AbstractCollection ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"构造方法 ArrayList有三个构造方法 无参构造方法 /** * Constructs an empty list with an initial capacity of ten.　默认会给10的大小，所以说一开始arrayList的容量是10. */ //ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData; 　public ArrayList() {　super(); //调用父类中的无参构造方法，父类中的是个空的构造方法 this.elementData = EMPTY_ELEMENTDATA; //EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。 } 有参构造方法 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) { super(); //父类中空的构造方法 if (initialCapacity \u003c 0) //判断如果自定义大小的容量小于0，则报下面这个非法数据异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; //将自定义的容量大小当成初始化elementData的大小 } 有参构造方法(不常用) //这个构造方法不常用，举个例子就能明白什么意思 /* Strudent exends Person ArrayList\u003cPerson\u003e、 Person这里就是泛型 我还有一个Collection\u003cStudent\u003e、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection\u003cStudent\u003e转换为ArrayList\u003cSudent\u003e这就是这个构造方法的作用 */ public ArrayList(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); //转换为数组 size = elementData.length; //数组中的数据个数 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。 elementData = Arrays.copyOf(elementData, size, Object[].class); }　 ###add()方法 add(E) //默认直接在末尾添加元素 add(int，E)//在特定位置添加元素，也就是插入元素 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"remove()方法 remove(int)//通过删除指定位置上的元素 remove(Object)//这个方法可以看出来，arrayList是可以存放null值得。 clear()//将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:3","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"set()方法 设定指定下标索引的元素值 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:4","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"indexOf()方法 从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:5","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get()方法 get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0） ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:6","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList是如何扩容的？ 扩容操作 /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 新容量扩大到原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) // 如果新容量还是比所需的最小容量小，则让新容量等于所需的最小容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) // 如果新容量超过了Integer.MAX_VALUE - 8，继续计算 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 所需的最小容量minCapacity 接近size elementData = Arrays.copyOf(elementData, newCapacity); } 扩容计算，int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); oldCapacity 是ArrayList 内部数组长度，oldCapacity » 1 是位运算的右移操作，右移一位相当于除以2，新的容量 newCapacity 为之前容量的1.5倍。 elementData = Arrays.copyOf(elementData, newCapacity); 对 elementData 数组进行扩容。 private static int hugeCapacity(int minCapacity) { if (minCapacity \u003c 0) // overflow throw new OutOfMemoryError(); return (minCapacity \u003e MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } ArrayList 扩容每次都是原容量的1.5倍吗？ 从源码中可以看出，当使用无参构造方法创建一个 ArrayList 实例，调用 add 方法添加第一个元素的时候，calculateCapacity 方法返回的是默认初始容量 DEFAULT_CAPACITY 大小为10；当使用指定初始容量创建ArrayList 实例，调用 addAll 方法添加多个元素的时候，原容量的1.5倍也无法存放元素的时候，会创建一个更大（不会超过 Integer.MAX_VALUE）的数组来存放元素。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:3:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap源码阅读 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } //第四个参数是，只有当key对应的位置为空的时候，才进行替换，一般设置为false //第五个参数如果是false，表示是在第一次放置+初始化数组容量的时候调用。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; //如果table数组为空，则进行第一次resize,扩容到初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果key在数组中映射的位置上的元素为空，没有产生哈希冲突，则直接放置 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; //如果key值相同，则直接覆盖 if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; //如果key值不同，则产生了哈希冲突，需要解决冲突 else if (p instanceof TreeNode)//如果当前是个树节点，则需要往树上放置元素 e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { //是个链表 for (int binCount = 0; ; ++binCount) { //如果走到链表的末尾，则直接新建一个节点，插入到链表末尾 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //判断需不需要进行变形，把链表变成红黑树，提高查找效率 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果当前的key值和链表上的某个key值相同 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; //指针移动 p = e; } } //如果循环结束后，e不等于null，则e的value值需要被替换成新的value值 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //HashMap的这个函数是空的，LinkedHashMap继承HashMap重写了这个方法，用来实现插入有序，或者LRU访问 afterNodeAccess(e); return oldValue; } } //修改数++ ++modCount; //如果当前数组的容量超过了扩容的阈值，则进行扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get方法 //根据key值获取 public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u003cK,V\u003e getNode(int hash, Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k; //table数组不为空,且length\u003e0，且hash值和数组长度做\u0026运算得到的那个bucket不为空 if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { //如果是第一个节点，则直接返回第一个节点 if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; //开始找下一个节点 if ((e = first.next) != null) { //如果下一个节点是红黑树节点 if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); //则开始在树上找节点 do { //如果是链表节点，一直遍历链表，知道找到。 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } //否则直接返回空 return null; } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap是如何扩容的？ HashMap 中的 resize 方法主要包含两部分逻辑： 初始化数组 table，并设置阈值。 数组容量翻倍，将元素迁移到新数组。 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u003e 0) { // 第一次进来，table为null，oldCap为0，不会进入这里 if (oldCap \u003e= MAXIMUM_CAPACITY) { // 扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; // 取整型最大值(2^31-1)，这样以后就不会扩容了 return oldTab; } else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 // oldCap翻倍得到newCap oldCap \u003e= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u003c\u003c 1; // double threshold } else if (oldThr \u003e 0) // initial capacity was placed in threshold // 第一次进来，如果手动设置了初始容量initialCapacity，这里为true，则将threshold作为初始容量 newCap = oldThr; else { // zero initial threshold signifies using defaults // 如果没有手动设置initialCapacity，则设为默认值16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { // 第一次进来，这里必为true，重新计算 threshold = capacity * Load factor float ft = (float)newCap * loadFactor; newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; table = newTab; if (oldTab != null) { // 对oldTab中所有元素进行rehash。由于每次扩容是2次幂的扩展(指数组长度/桶数量扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置 for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { // 数组j位置的元素不为空，需要该位置上的所有元素进行rehash oldTab[j] = null; if (e.next == null) // 桶中只有一个元素，则直接rehash newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) // 桶中是树结构 ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order // 桶中是链表结构（JDK1.7中旧链表迁移新链表的时候，用的是头插法，如果在新表的数组索引位置相同，则链表元素会倒置；但是JDK1.8不会倒置，用的是双指针） Node\u003cK,V\u003e loHead = null, loTail = null; // low位链表，其桶位置不变，head和tail分别代表首尾指针 Node\u003cK,V\u003e hiHead = null, hiTail = null; // high位链表，其桶位于追加后的新数组中 Node\u003cK,V\u003e next; do { next = e.next; if ((e.hash \u0026 oldCap) == 0) { // 是0的话索引没变，是1的话索引变成“原索引+oldCap” if (loTail == null) loHead = e; // 总是指向头结点 else loTail.next = e; // 该操作有可能会改变原链表结构 loTail = e; // 总是指向下一个节点，直到尾节点 } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; // 原索引 } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; // 原索引+oldCap } } } } } return newTab; } HashMap 每次扩容都是建立一个新的 table 数组，长度和容量阈值都变为原来的两倍，然后把原数组元素重新映射到新数组上，具体步骤如下： 首先会判断 table 数组长度，如果大于 0 说明已被初始化过，那么按当前 table 数组长度的 2 倍进行扩容，阈值也变为原来的 2 倍 若 table 数组未被初始化过，且 threshold(阈值)大于 0 说明调用了 HashMap(initialCapacity, loadFactor) 构造方法，那么就把数组大小设为 threshold 若 table 数组未被初始化，且 threshold 为 0 说明调用 HashMap() 构造方法，那么就把数组大小设为 16，threshold 设为 16*0.75 接着需要判断如果不是第一次初始化，那么扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去，如果节点是红黑树类型的话则需要进行红黑树的拆分 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:5:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap从Java7到Java8发生了哪些变化？ JDK 7 是先对 size++ 进行检查， 如果超过阈值， 则扩容，最后把节点放入 table。 而 JDK 8 相反，先把节点放入， 放入后的 size 若超出， 则扩容 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:6:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"为什么HashMap不是线程安全的？ JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。 JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:7:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection体系简介 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"list Collection\u003cInteger\u003e c = new LinkedHashSet\u003c\u003e(); // IntegerList List\u003cInteger\u003e list = new ArrayList\u003c\u003e(c); // 等价于 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(); list2.addAll(c); // 等价于 List\u003cInteger\u003e list3 = new ArrayList\u003c\u003e(); for (Integer i : c) { list3.add(i); } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Set 只是简单通过object.contains()判断添加新元素时是否重复，从而实现去重的 Set 是很低效的，这就引出了对象的 hashcode。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Java世界第⼆重要的约定 hashCode: 同⼀个对象必须始终返回相同的 hashCode 两个对象的 equals 返回 true，必须返回相同的 hashCode 两个对象不等，也可能返回相同的 hashCode ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:3","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashSet HashSet 是无序的，是最常用的 Set 实现。 可以利用 set 为 list 过滤去重： List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(2); list.add(3); list.add(4); list.add(3); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(list); LinkedHashSet 是有序的，顺序就是插入元素时的顺序。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:4","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collections ⼯具⽅法集合 emptySet(): 等返回⼀一个⽅方便便的空集合 synchronizedCollection: 将⼀一个集合变成线程安全的 unmodifiableCollection: 将⼀一个集合变成不不可变的（也可以使⽤用Guava的Immutable） ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:5","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Map 体系 map 是 一个将 keys 映射到 values 的对象，键不能重复，每个键只能映射一个值，值可以重复。 keySet()返回键的集合，因为键不可重复，所以可以返回一个 set； values()返回值的集合，因为值可以重复，所以返回的是 collection。 注意：keySet()和 map背后的 keys 是同一组数据，所以二者的修改会相互影响。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap HashMap 是最常用、最高效的 Map 实现。 HashMap 的扩容，思路同样是创建更大的空间，然后把之前的数据 copy 进来。 HashMap 是多线程不安全的，可使用 ConcurrentHashMap。 Java 7 开始会采用代替链表 HashMap 和 HashSet 本质上是同一个东西： HashMap 的 key 集合（set）就是 HashSet，而 HashSet 内部其实就是个 HashMap，毕竟 HashSet 拥有的功能 HashMap 都有。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"有序集合TreeSet/TreeMap TreeSet 可以排序（默认是自然顺序）。 HashSet、LinkedHashSet 与 TreeSet 对比： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = Arrays.asList(1000, -13, 0, -41656, 1250, 555); Set set1 = new HashSet\u003c\u003e(list); Set set2= new LinkedHashSet(list); Set set3 = new TreeSet(list); System.out.println(set1); System.out.println(set2); System.out.println(set3); } } [0, 1250, -41656, 1000, 555, -13] [1000, -13, 0, -41656, 1250, 555] [-41656, -13, 0, 555, 1000, 1250] TreeMap 同理 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Guava 不要重复发明轮⼦子！尽量量使⽤用经过实战检验的类库 Lists/Sets/Maps ImmutableMap/ImmutableSet Multiset/Multimap BiMap ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:10:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"jar jar是将很多类文件打包后的一个压缩包,导入 jar 后,可以直接使用里面的类或调用其中的功能。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:1:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"java包的原理 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"传递性依赖 我们依赖的包还依赖了别的类，这种依赖是具有传递性的。 传递性依赖带来的最大的问题就是： 我们在 -classpath 后会添加项目依赖的各种各样的 jar 包； 如果两个仅仅不同版本的 jar 包被同时写进了 -classpath 参数里面； JVM 在 classpath 中寻找类文件的顺序是从前找到后的，也就是说如果有两个仅仅不同版本的 jar ：demo-1.0.jar 和 demo-2.0.jar ，哪个放在前面哪个就会被使用。 如果 demo-1.0.jar 的顺序在 demo-2.0.jar 之前，就会使用demo-1.0.jar加载的类文件，这样的话高版本的jar就会不生效。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven包的管理 Maven 是一个项目管理工具它包含： 一个项目对象模型 一组标准集合 一个项目生命周期 一个依赖管理系统 用来运行定义在生命周期阶段中插件目标的逻辑 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven怎么进行管理 Maven 包管理的做法是：Convention over configuration（约定优于配置原则），体现在 POM。 POM是 Maven 工程的基本工作单元，是一个 XML 文件。 该文件中包含了项目的基本信息，用于描述项目如何构建，声明项目依赖等等。 pom.xml \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ehcsp\u003c/groupId\u003e \u003cartifactId\u003efix-bug-in-integer-equals\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003ealiyunMavenMirror\u003c/id\u003e \u003cactivation\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003c/profiles\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.1\u003c/version\u003e \u003cconfiguration\u003e \u003cargLine\u003e-Dfile.encoding=UTF-8\u003c/argLine\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 引入第三方包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 里面加入了junit-jupiter-engine的jar 如果在本地仓库没有找到对应的 jar 包，Maven 就会从远程的中央仓库进行下载，然后放到本地仓库中。 Maven 中央仓库位置 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突及解决办法 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突 相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"解决冲突的办法 直接依赖C2 排除C1 通过Maven helper插件来解决包冲突问题 排除 \u003cdependency\u003e \u003cgroupId\u003exxx\u003c/groupId\u003e \u003cartifactId\u003exxx\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eyyy\u003c/groupId\u003e \u003cartifactId\u003eyyy\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 排除了xxx依赖中的后代yyy依赖，也可以解决包冲突的问题 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:2","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"git系列操作 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:0:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"git六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor \"code --wait\" git config --global core.autocrlf input 注意： 上面的英文名和邮箱跟 GitHub 没有关系。 可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:1:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"新建代码库 # 在当前目录新建一个 Git 代码库 git init # 新建一个目录，将其初始化为 Git 代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:2:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"配置文件 # 显示当前的 Git 配置 git config --list # 编辑 Git 配置文件 git config -e [--global] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:3:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区 git commit -m [message] # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] # 提交工作区自上次 commit 之后的变化，直接到仓库区 git commit -a # 提交时显示所有 diff 信息(推荐) git commit -v # 使用一次新的 commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 git commit --amend -m [message] # 重做上一次 commit，并包括指定文件的新变化 git commit --amend ... ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:4:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定 commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个 commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete git branch -dr ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:5:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"提交代码 git pull 提交代码到远程仓库 git push -u origin master 提交本地指定分支master代码到远程仓库 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:6:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"ls命令 list 的缩写,可以查看文件权限(包括目录、文件夹、文件权限),查看目录信息。 ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cd命令 cd [目录名] 进入目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"pwd命令 pwd 查看当前路径 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mkdik命令 mkdir t 在当前工作目录下创建名为 t的文件夹 mkdir -p /tmp/test/t1/t 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"rm命令 rm -i *.log 删除任何 .log 文件，删除前逐一询问确认 rm -rf test 删除 test 子目录及子目录中所有档案删除，并且不用一一确认 rm -- -f* 删除以 -f 开头的文件 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mv命令 mv test.log test1.txt 将文件 test.log 重命名为 test1.txt mv llog1.txt log2.txt log3.txt /test3 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv -i log1.txt log2.txt 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv * ../ 移动当前文件夹下的所有文件到上一级目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cp命令 -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cat命令 cat filename 一次显示整个文件 cat \u003e filename 从键盘创建一个文件 cat file1 file2 \u003e file 将几个文件合并为一个文件 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:1","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"常用操作命令 Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:2","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"which 命令 which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]