[{"categories":["java知识"],"content":"为什么会出现跨域问题 出于浏览器的同源策略限制。 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能， 如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:1:0","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:2:0","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"非同源限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 AJAX 请求 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:3:0","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"java后端实现CORS跨域请求的方式 对于 CORS的跨域请求，主要有以下几种方式可供选择： 返回新的CorsFilter 重写 WebMvcConfigurer 使用注解 @CrossOrigin 手动设置响应头 (HttpServletResponse) 自定web filter实现跨域(推荐) ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:0","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"1.返回新的CorsFilter 在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。 @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1. 添加 CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin(\"*\"); //是否发送 Cookie config.setAllowCredentials(true); //放行哪些请求方式 config.addAllowedMethod(\"*\"); //放行哪些原始请求头部信息 config.addAllowedHeader(\"*\"); //暴露哪些头部信息 config.addExposedHeader(\"*\"); //2. 添加映射路径 UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource(); corsConfigurationSource.registerCorsConfiguration(\"/**\",config); //3. 返回新的CorsFilter return new CorsFilter(corsConfigurationSource); } } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:1","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"2.重写 WebMvcConfigurer @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") //是否发送Cookie .allowCredentials(true) //放行哪些原始域 .allowedOrigins(\"*\") .allowedMethods(new String[]{\"GET\", \"POST\", \"PUT\", \"DELETE\"}) .allowedHeaders(\"*\") .exposedHeaders(\"*\"); } } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:2","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"3.使用注解 @CrossOrigin 在控制器(类上)上使用注解 @CrossOrigin，表示该类的所有方法允许跨域。 @RestController @CrossOrigin(origins = \"*\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"hello world\"; } } 在方法上使用注解 @CrossOrigin @RequestMapping(\"/hello\") @CrossOrigin(origins = \"*\") //@CrossOrigin(value = \"http://localhost:8081\") //指定具体ip允许跨域 public String hello() { return \"hello world\"; } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:3","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"4.手动设置响应头 (HttpServletResponse) 使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域， 这里 Origin的值也可以设置为 “*”,表示全部放行。 @RequestMapping(\"/index\") public String index(HttpServletResponse response) { response.addHeader(\"Access-Allow-Control-Origin\",\"*\"); return \"index\"; } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:4","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"5.自定web filter实现跨域(推荐) 首先编写一个过滤器，可以起名字为MyCorsFilter.java package com.mesnac.aop; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; @Component public class MyCorsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with,content-type\"); chain.doFilter(req, res); } public void init(FilterConfig filterConfig) {} public void destroy() {} } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:5","tags":["java"],"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["笔记"],"content":"提交指南 例子： ","date":"2022-03-31","objectID":"https://hahaen.github.io/github%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97/:1:0","tags":["笔记"],"title":"Github提交指南","uri":"https://hahaen.github.io/github%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97/"},{"categories":["笔记"],"content":" 启动hugo服务(预览) hugo server -D 创建MD hugo new posts/名字.md 构建页面 hugo -D ","date":"2022-03-31","objectID":"https://hahaen.github.io/hugo%E6%8C%87%E5%8D%97/:0:0","tags":["笔记"],"title":"Hugo指南","uri":"https://hahaen.github.io/hugo%E6%8C%87%E5%8D%97/"},{"categories":["部署"],"content":"服务器配置java injdk.cn 各种JAVA JDK的镜像分发 ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:1:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"配置docker ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:2:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"下载代码 如 ： git clone https://github.com/hahaen/wxshop.git ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:3:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"启动MySQL docker run -d -v `pwd`/wxshop-data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wxshop --name=wxshop-mysql mysql 需要改成自己地址 创建order数据库 docker exec -it wxshop-mysql mysql -uroot -proot -e 'create database if not exists `order`' ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:4:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"redis docker run -p 6379:6379 -d redis ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:5:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"zookeeper docker run -p 2181:2181 -d zookeeper ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:6:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"nginx events{} http { include mime.types; upstream app { server 172.23.0.1:8080; server 172.23.0.1:8081; } server { location /api { proxy_pass http://app; } location / { root /static; autoindex on; } } } 注意：如果只有 html 是对的，css js 都写错写成了 text/plain 而不是 text/css 一定要在配置加上include mime.types; 改成机器上的ip 启动nginx start_nginx.sh docker run -d -p 5000:80 -v 文件目录/build:/static -v (/root/nginx-conf/nginx.conf)配置目录:/etc/nginx/nginx.conf nginx ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:7:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["部署"],"content":"tmux 终端复用器 tmux教程 创建0：tmux new -s 0 创建1：tmux new -s 1 查看所有tmux: tmux ls 重新接入已存在的会话：tmux attach -t 0 退出（下次可进入）：Ctrl+b 再单独按d 退出（杀死）：Ctrl+d ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:8:0","tags":["服务器"],"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["java知识"],"content":"相比于JDK7，HashMap在JDK8中做链表结构做了优化（但仍然线程不安全），在一定条件下将链表转为红黑树，提升查询效率。 ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:0:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"put()操作 先根据key确定在哈希table中的下标，找到对应的bucket，遍历链表（或红黑树），做插入操作。 在JDK7中，新增结点是使用头插法，但在JDK8中，在链表使用尾插法，将待新增结点追加到链表末尾。 红黑树的转换操作如下： /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) { int n, index; Node\u003cK,V\u003e e; // 若表为空，或表长度小于MIN_TREEIFY_CAPACITY，也不做转换，直接做扩容处理。 if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026 hash]) != null) { TreeNode\u003cK,V\u003e hd = null, tl = null; do { TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:1:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"扩容操作 什么场景下会触发扩容？ 哈希table为null或长度为0； Map中存储的k-v对数量超过了阈值threshold； 链表中的长度超过了TREEIFY_THRESHOLD，但表长度却小于MIN_TREEIFY_CAPACITY。 一般的扩容分为2步，第1步是对哈希表长度的扩展（2倍），第2步是将旧table中的数据搬到新table上。 那么，在JDK8中，HashMap是如何扩容的呢？ // 前面已经做了第1步的长度拓展，我们主要分析第2步的操作：如何迁移数据 table = newTab; if (oldTab != null) { // 循环遍历哈希table的每个不为null的bucket // 注意，这里是\"++j\"，略过了oldTab[0]的处理 for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 若只有一个结点，则原地存储 if (e.next == null) newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order // \"lo\"前缀的代表要在原bucket上存储，\"hi\"前缀的代表要在新的bucket上存储 // loHead代表是链表的头结点，loTail代表链表的尾结点 Node\u003cK,V\u003e loHead = null, loTail = null; Node\u003cK,V\u003e hiHead = null, hiTail = null; Node\u003cK,V\u003e next; do { next = e.next; // 以oldCap=8为例， // 0001 1000 e.hash=24 // \u0026 0000 1000 oldCap=8 // = 0000 1000 --\u003e 不为0，需要迁移 // 这种规律可发现，[oldCap, (2*oldCap-1)]之间的数据， // 以及在此基础上加n*2*oldCap的数据，都需要做迁移，剩余的则不用迁移 if ((e.hash \u0026 oldCap) == 0) { // 这种是有序插入，即依次将原链表的结点追加到当前链表的末尾 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; // 需要搬迁的结点，新下标为从当前下标往前挪oldCap个距离。 newTab[j + oldCap] = hiHead; } } } } } ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:2:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"get()操作 先根据key计算hash值，进一步计算得到哈希table的目标index 若此bucket上为红黑树，则再红黑树上查找，若不是红黑树，遍历链表。 public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u003cK,V\u003e getNode(int hash, Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k; if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:3:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"HashMap、HashTable是什么关系？ 共同点: 底层都是使用哈希表 + 链表的实现方式。 异同点: 从层级结构上看，HashMap、HashTable有一个共用的Map接口。另外，HashTable还单独继承了一个抽象类Dictionary； HashTable线程安全，HashMap线程不安全； 初始值和扩容方式不同。HashTable的初始值为11，扩容为原大小的2*d+1。 容量大小都采用奇数且为素数，且采用取模法，这种方式散列更均匀。 但有个缺点就是对素数取模的性能较低（涉及到除法运算）, 而HashTable的长度都是2的次幂，设计就较为巧妙，这种方式的取模都是直接做位运算，性能较好。 HashMap的key、value都可为null，且value可多次为null，key多次为null时会覆盖。 当HashTable的key、value都不可为null，否则直接NPE(NullPointException)。 ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:4:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"保证HashMap的线程安全 可以添加synchronized关键字 ","date":"2022-03-17","objectID":"https://hahaen.github.io/hashmap/:5:0","tags":["java"],"title":"HashMap","uri":"https://hahaen.github.io/hashmap/"},{"categories":["java知识"],"content":"加密盐 加密盐也是比较常听到的一个概念，盐就是一个随机字符串用来和我们的加密串拼接后进行加密。 加盐主要是为了提供加密字符串的安全性。 假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串， 而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"加密过程(用户注册) 最终的密文是以下两个内容的函数： 用户输入的密码明文 盐值 最后要将以下内容存入数据库： 用户的用户名 最终的密文 加密所用的盐值 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:1","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"校验过程(用户登录) ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:2","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"不可逆加密 常见的不可逆加密算法有MD5，HMAC，SHA1、SHA-224、SHA-256、SHA-384，和SHA-512 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法 SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高。 其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。 不可逆加密算法最大的特点就是密钥 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"对称加密算法 对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。 常见的对称加密算法有DES、3DES、AES128、AES192、AES256 (默认安装的 JDK 尚不支持 AES256，需要安装对应的 jce 补丁进行升级 jce1.7，jce1.8)。 其中AES后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适用的场景就是内网环境中的加解密。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:0","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"非对称加密算法 非对称加密算法有两个密钥，这两个密钥完全不同但又完全匹配。 只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。 常见的非对称加密有RSA、SM2等。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:4:0","tags":["java"],"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"Shiro框架 是一个轻量级的安全框架，主要提供了 授权、认证、加密、会话管理这几个功能。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:1:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"shiro安全数据源有哪些 数据库 静态ini文件 session ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:2:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro运行流程 比如一个登陆流程： 首先调用Subject.login(token)进行登录，他会委托给SecurityManager SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator会把相应的token传入Realm，从Realm获取身份验证信息， 如果没有就返回认证失败，有的话就继续执行操作。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:3:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro 的优点 简单的身份认证, 支持多种数据源；非常简单的加密 API； 对角色的简单的授权, 支持细粒度的授权(方法级)； 支持一级缓存，以提升应用程序的性能； 内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境； 不跟任何的框架或者容器捆绑, 可以独立运行。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:4:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro 的3个核心组件 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Subject 正与系统进行交互的人, 或某一个第三方服务。 所有 Subject 实例都被绑定到一个SecurityManager 上。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:1","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"SecurityManager Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务。 当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:2","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Realms 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和授权。 Shiro 提供了多种可用的 Realms 来获取安全相关的数据. 例如关系数据库(JDBC), INI 及属性文件等。 可以定义自己 Realm 实现来代表自定义的数据源。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:3","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"如何配置在 Spring 中配置使用 Shiro 在 web.xml 中配置 Shiro 的 Filter； 在 Spring 的配置文件中配置 Shiro； 配置自定义 Realm：实现自定义认证和授权； 配置 Shiro 实体类使用的缓存策略； 配置 SecurityManager； 配置保证 Shiro 内部 Bean 声明周期都得到执行的 Lifecycle Bean 后置处理器； 配置AOP 式方法级权限检查； 配置 Shiro Filter。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:6:0","tags":["java"],"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"对Redis 的了解？ Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、 支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:1:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 一般都有哪些使用场景？ Redis 适合的场景 缓存：减轻 MySQL 的查询压力，提升系统性能； 排行榜：利用 Redis 的 SortSet（有序集合）实现； Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上， 这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制， 比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦； Redis 不适合的场景 数据量太大 数据访问频率非常低的业务 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:2:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis支持哪几种数据类型？ string：最基本的数据类型，二进制安全的字符串，最大512M。 list：按照添加顺序保持顺序的字符串列表。 set：无序的字符串集合，不存在重复的元素。 sorted set：已排序的字符串集合。 hash：key-value对的一种集合。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:3:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis主要有哪些功能？ 数据缓存功能 分布式锁的功能 支持数据持久化 支持事务 支持消息队列 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:4:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 为什么这么快？ 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速； 数据结构简单，对数据操作也简单； 采用单线程，避免了不必要的上下文切换和竞争条件， 也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题， 不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 使用多路 I/O 复用模型，非阻塞 IO。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:5:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是缓存穿透？怎么解决？ 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存， 这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决办法: 缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存， 但它的过期时间会很短，最长不超过五分钟。 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉， 从而避免了对底层存储系统的查询压力。 缓存空对象带来的问题: 空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间 缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:6:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是缓存雪崩？该如何解决？ 如果缓存集中在一段时间内失效，所有的查询都落在数据库上，造成了缓存雪崩。 解决办法： 加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。 比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待； 数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key， 设置不同的过期时间，让缓存失效的时间点尽量均匀； 做二级缓存：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2， Cache1 缓存失效时间设置为短期，Cache2 设置为长期。 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:7:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"怎么保证缓存和数据库数据的一致性？ 设置了合理的键的过期时间 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:8:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 持久化有几种方式？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 Redis 提供了两种持久化方式：RDB（默认） 和 AOF。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:9:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"RDB RDB 是 Redis DataBase 的缩写。 按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。 即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。 核心函数：rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）两个函数。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:9:1","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"AOF AOF 是 Append-only file 的缩写。 Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。 当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 每当执行服务器（定时）任务或者函数时，flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作： WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件； SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:9:2","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"RDB 和 AOF 的区别： AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据； AOF比 RDB 更安全也更大； RDB 性能比 AOF 好； 如果两个都配了优先加载 AOF。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:9:3","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 常见性能问题和解决方案？ Master 最好不要做任何持久化工作， 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内； 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master \u003c- Slave1 \u003c- Slave2 \u003c- Slave3… ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:10:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis的过期键的删除策略 Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。 Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 Redis中同时使用了惰性过期和定期过期两种过期策略。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。 定期清楚：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:11:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis如何做内存优化？ 控制key的数量 缩减键值对象,降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度 编码优化 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:12:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis事务 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。 事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:1","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis事务的三个阶段 事务开始 MULTI 命令入队 事务执行 EXEC ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:2","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"事务管理概述 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持久性（Durability） ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:3","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis事务支持隔离性吗 Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。 因此，Redis 的事务是总是带有隔离性的。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:4","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis事务保证原子性吗，支持回滚吗 Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:5","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis是单线程的，如何提高多核CPU的利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用， 在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:14:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存， 最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下， 每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。 缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。 对比: Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了； Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了； Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里； Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象； Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了； Redis可单独部署，多个项目之间可以共享，本地内存无法共享； Redis有专门的管理工具可以查看缓存数据。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:15:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"主从复制 主从架构的核心原理 当启动一个slave node的时候，它会发送一个PSYNC命令给master node 开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件， 同时还会将从客户端收到的所有写命令缓存在内存中。 RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。 然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。 主从复制的断点续传 如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份 无磁盘化复制 master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了 过期key处理 slave不会过期key，只会等待master过期key。 如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:16:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"由于主从延迟导致读取到过期数据怎么处理？ 通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key， 同样也会做过期检测，充分发挥Redis惰性删除的策略。 这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。 Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断， 如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:17:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis主从架构数据会丢失吗，为什么？ 有两种数据丢失的情况： 异步复制导致的数据丢失:因为master -\u003e slave的复制是异步的， 所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。 脑裂导致的数据丢失: 某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了， 然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:18:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"哨兵模式 每个哨兵(Sentinel)以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 ）。 若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。 sentinel节点会与其他sentinel节点进行“沟通”，投票选举一个sentinel节点进行故障处理， 在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:19:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"常见的分布式锁有哪些解决方案？ ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:20:0","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于关系型数据库，如MySQL 基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。 缺点： 数据库挂掉，会导致业务系统不可用 没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。 只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。 没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。 同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:20:1","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于Redis实现 优点： Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。 缺点： Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮； key 的过期时间设置多少不明确，只能根据实际情况调整； 需要自己不断去尝试获取锁，比较消耗性能。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:20:2","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于zookeeper 优点： zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁， 只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。 缺点： 在高请求高并发下，系统疯狂的加锁释放锁，最后 zookeeper 承受不住这么大的压力可能会存在宕机的风险。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:20:3","tags":["java"],"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是反射？ 将类的各个组成部分封装为其他对象的过程就叫做反射， 其中 组成部分 指的是我们类的 成员变量（Field）、构造方法（Constructor）、成员方法（Method）。 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:1:0","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"使用反射的优缺点? 优点: 在程序运行过程中可以操作类对象，增加了程序的灵活性 解耦，从而提高程序的可扩展性，提高代码的复用率，方便外部调用 对于任何一个类，当知道它的类名后，就能够知道这个类的所有属性和方法；而对于任何一个对象，都能够调用它的一个任意方法 缺点： 性能问题：Java 反射中包含了一些动态类型，JVM 无法对这些动态代码进行优化， 因此通过反射来操作的方式要比正常操作效率更低。 安全问题：使用反射时要求程序必须在一个没有安全限制的环境中运行， 如果程序有安全限制，就不能使用反射。 程序健壮性：反射允许代码执行一些平常不被允许的操作，破坏了程序结构的抽象性， 导致平台发生变化时抽象的逻辑结构无法被识别。 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:2:0","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"反射机制的作用 反编译：.class–\u003e.java 通过反射机制访问java对象的属性，方法，构造方法等； ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:3:0","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"反射创建api getDeclaredMethods [] 获取该类的所有方法 getReturnType() 获取该类的返回值 getParameterTypes() 获取传入参数 getDeclaredFields() 获取该类的所有字段 setAccessible 允许访问私有成员 实现方式： 调用运行时类本身的.class属性 利用运行时类的对象获取（getclass()） 通过类的静态方法获取 通过类的加载器 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:4:0","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"获取 Class 对象的方式 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:5:0","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"Class.forName(“全类名”) 源代码阶段，它能将字节码文件加载进内存中，然后返回 Class 对象， 多用于配置文件中，将类名定义在配置文件中，通过读取配置文件来加载类。 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:5:1","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"类名.class 类对象阶段，通过类名的 class 属性来获取，多用于参数的传递。 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:5:2","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"对象.getClass() 运行时阶段，getClass() 定义在 Object 类中，表明所有类都能使用该方法，多用于对象的获取字节码的方式。 定义一个 Person 类，用于后续反射功能的测试: public void setScore(float score) { this.score = score; } public int getRank() { return rank; } public void setRank(int rank) { this.rank = rank; } @Override public String toString() { final StringBuffer sb = new StringBuffer(\"Person{\"); sb.append(\"age=\").append(age); sb.append(\", name='\").append(name).append('\\''); sb.append(\", id=\").append(id); sb.append(\", grade=\").append(grade); sb.append(\", score=\").append(score); sb.append(\", rank=\").append(rank); sb.append('}'); return sb.toString(); } } 定义好 Person 类之后，我们尝试用 3 种不同的方式来获取 Class 对象 public class Demo1 { public static void main(String[] args) throws ClassNotFoundException { // 第一种方式，Class.forName(\"全类名\") Class class1 = Class.forName(\"com.hahaen.Person\"); System.out.println(class1); // 第二种方式，类名.class Class class2 = Person.class; System.out.println(class2); // 第三种方式，对象.getName() Person person = new Person(); Class class3 = person.getClass(); System.out.println(class3); // 比较三个对象是否相同 System.out.println(class1 == class2); System.out.println(class1 == class3); } } com.hahaen.Person com.hahaen.Person com.hahaen.Person true true 比较结果返回的是两个 true， 说明通过上述三种方式获取的 Class 对象都是同一个，同一个字节码文件（*.class）在一次运行过程中只会被加载一次。 ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:5:3","tags":["java"],"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["java知识"],"content":"DNS DNS 的全称是 Domain Name System 或者 Domain Name Service， 它主要的作用就是将人们所熟悉的网址 (域名) “翻译”成电脑可以理解的 IP 地址， 这个过程叫做 DNS 域名解析。 打个比方，我们登百度的地址的时候，都是敲www.baidu.com，进行登陆，难道你会去敲IP地址登百度？明显，域名容易记忆。 而且，一个域名往往对应多个DNS地址 ","date":"2022-03-14","objectID":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"DNS的原理","uri":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"浏览器中输入URL到返回页面的全过程？ 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址，发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染； ","date":"2022-03-14","objectID":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/:2:0","tags":["java"],"title":"DNS的原理","uri":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"什么是微服务架构? 微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务， 每个微服务运行在自己的进程中，并使用轻量级的机制通信。 这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。 这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:1:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"为什么需要学习Spring Cloud 首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？ 可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了， spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来， 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理。 什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！ 而springcloud完成这些只需要一个jar的依赖就可以了！ springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:2:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud 是什么 Spring Cloud是一系列框架的有序集合。 它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发， 如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等， 都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来， 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理， 最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:3:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud的优缺点 优点： 耦合度比较低。不会影响其他模块的开发。 减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。 配置比较简单，基本用注解就能实现，不用使用过多的配置文件。 微服务跨平台的，可以用任何一种语言开发。 每个微服务可以有自己的独立的数据库也有用公共的数据库。 直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。 缺点： 部署比较麻烦，给运维工程师带来一定的麻烦。 针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。 系统集成测试比较麻烦 性能的监控比较麻烦。【最好开发一个大屏监控系统】 总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:4:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringBoot和SpringCloud的区别？ SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来， 为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务 SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系 SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:5:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud由什么组成 Spring Cloud Eureka：服务注册与发现 Spring Cloud Zuul：服务网关 Spring Cloud Ribbon：客户端负载均衡 Spring Cloud Feign：声明性的Web服务客户端 Spring Cloud Hystrix：断路器 Spring Cloud Config：分布式统一配置管理 等20几个框架，开源一直在更新 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:6:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"使用 Spring Boot 开发分布式微服务时，我们面临什么问题 与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。 服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。 它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。 冗余-分布式系统中的冗余问题。 负载平衡 –负载平衡改善跨多个计算资源的工作负荷， 如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。 性能-问题 由于各种运营开销导致的性能问题。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:7:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud 和dubbo区别? 服务调用方式：dubbo是RPC springcloud Rest Api 注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper 服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关， 作为路由服务器，进行消费者的请求分发,springcloud支持断路器， 与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:8:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:9:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务注册和发现是什么意思？Spring Cloud 如何实现？ 当我们开始一个项目时，我们通常在属性文件中进行所有的配置。 随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。 有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。 由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找， 因此无需处理服务地点的任何更改和处理。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:10:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Eureka Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心， 系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳， 这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:11:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka怎么实现高可用 集群吧，注册多台Eureka，然后把SpringCloud服务互相注册， 客户端从Eureka获取信息时，按照Eureka的顺序来访问。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:12:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Eureka的自我保护模式 默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳， Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息， 不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:13:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"DiscoveryClient的作用 可以从注册中心中根据服务别名获取注册的服务器信息。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:14:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 ZooKeeper中的节点服务挂了就要选举,在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群 Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的 Eureka本质上是一个工程,而ZooKeeper只是一个进程 Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪 ZooKeeper保证的是CP，Eureka保证的是AP ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:15:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:16:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是网关? 网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:17:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"网关的作用是什么 统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:18:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Zuul（服务网关） Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同， 网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理： 动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新 路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配 反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端 它可以和Eureka,Ribbon,Hystrix等组件配合使用 Zuul的应用场景：对外暴露，权限校验，服务聚合，日志审计等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:19:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"网关与过滤器有什么区别 网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:20:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"常用网关框架有那些？ Nginx、Zuul、Gateway ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:21:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul与Nginx有什么区别？ Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。 Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言， 对程序员要求较高，可以使用Nginx做Zuul集群。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:22:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"既然Nginx可以实现网关？为什么还需要使用Zuul框架 Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:23:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"如何设计一套API接口 考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网， 为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用， 需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:24:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"ZuulFilter常用有那些方法 Run()：过滤器的具体业务逻辑 shouldFilter()：判断过滤器是否有效 filterOrder()：过滤器执行顺序 filterType()：过滤器拦截位置 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:25:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"如何实现动态Zuul网关路由转发 通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表， Zuul内部使用Ribbon实现本地负载均衡和转发。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:26:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul网关如何搭建集群 使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream， 默认使用轮询机制对Zuul集群发送请求。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:27:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:28:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"负载平衡的意义什么？ 简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天， 我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群， 他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。 在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接， 中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用， 最大化吞吐量，最小化响应时间并避免任何单一资源的过载。 使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。 负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:29:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon是什么？ Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法 Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。 简单的说，就是在配置文件中列出后面所有的机器， Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。 我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx） ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:30:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Nginx与Ribbon的区别 Nginx是反向代理同时可以实现负载均衡， nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。 Ribbon是客户端负载均衡，从注册中心读取目标服务器信息， 然后客户端采用轮询策略对服务直接访问，全程在客户端操作。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:31:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon底层实现原理 Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数， 使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:32:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"@LoadBalanced注解的作用 开启客户端负载均衡。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:33:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Hystrix ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:34:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是断路器 当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应） 断路器有三种状态: 打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象, 断路器完全打开 那么下次请求就不会请求到该服务 半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭 关闭状态：当服务一直处于正常状态 能正常调用 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:35:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是 Hystrix？ 在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩 Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。 Hystrix有四种防雪崩方式: 服务降级：接口调用失败就调用本地的方法返回一个空 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息 服务隔离：隔离服务之间相互影响 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:36:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务雪崩效应 雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机， 大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中， 从而使整个项目的服务宕机崩溃.发生雪崩效应的原因有以下几点 单个服务的代码存在bug. 请求访问量激增导致服务发生崩溃(如大型商城的枪红包，秒杀功能) 服务器的硬件故障也会导致部分服务不可用. ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:37:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"在微服务中，如何保护服务? 一般使用使用Hystrix框架，实现服务隔离来避免出现服务的雪崩效应，从而达到保护服务的效果。 当微服务中，高并发的数据库访问量导致服务线程阻塞，使单个服务宕机，服务的不可用会蔓延到其他服务， 引起整体服务灾难性后果，使用服务降级能有效为不同的服务分配资源,一旦服务不可用则返回友好提示， 不占用其他服务资源，从而避免单个服务崩溃引发整体服务的不可用. ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:38:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务雪崩效应产生的原因 因为Tomcat默认情况下只有一个线程池来维护客户端发送的所有的请求， 这时候某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程， 其他请求处于等待状态，无法连接到服务接口。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:39:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"谈谈服务降级、熔断、服务隔离 服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。 服务熔断是在服务降级的基础上更直接的一种保护方式， 当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路， 之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。 服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。 服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:40:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务降级底层是如何实现的？ Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法 当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:41:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Feign ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:42:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Feign？ Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了， 直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:43:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud有几种调用接口方式 Feign RestTemplate ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:44:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon和Feign调用服务的区别 调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐 而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式， 将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了， 直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:45:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Bus ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:46:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是 Spring Cloud Bus？ Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。 Spring Cloud Bus 不能单独完成通信，需要配合MQ支持 Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的 Springcloud config实时刷新也必须采用SpringCloud Bus消息总线 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:47:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Config ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:48:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Config? Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持， 可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。 Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:49:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"分布式配置中心有那些框架？ Apollo、zookeeper、springcloud config。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:50:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"分布式配置中心的作用？ 动态变更项目配置信息而不必重新部署项目。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:51:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud Config 可以实现实时刷新吗？ springcloud config实时刷新采用SpringCloud Bus消息总线。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:52:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Gateway ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:53:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Gateway? Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。 网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。 使用了一个RouteLocatorBuilder的bean去创建路由， 除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思， 顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:54:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud主要项目 Spring Cloud的子项目，大致可分成两类 一类是对现有成熟框架\"Spring Boot化\"的封装和抽象，也是数量最多的项目 第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:55:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Config Config能够管理所有微服务的配置文件 集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:56:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Netflix(重点，这些组件用的最多) Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。 Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力； Feign：基于Ribbon和Hystrix的声明式服务调用组件； Zuul：API网关组件，对请求提供路由及过滤功能。 我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:57:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Bus 用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。 简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。 需要利用中间插件MQ ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:58:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Consul Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。 与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”， 内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案， 不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写， 因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件， 方便部署，与 Docker 等轻量级容器可无缝配合。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:59:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Security 安全工具包，他可以对 对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌 资源服务器之间的中继令牌 使Feign客户端表现得像OAuth2RestTemplate（获取令牌等）的拦截器 在Zuul代理中配置下游身份验证 Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。 可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统， 通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。 在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统， 如单点登录，令牌中继和令牌交换。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:60:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Sleuth 在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求。 如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂， 假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了， 那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。 Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:61:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Stream 轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:62:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Task Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。 在Spring Cloud Task中，我们可以灵活地动态运行任何任务， 按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目， 允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:63:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Zookeeper SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:64:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Gateway Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关， Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式， Spring Cloud Gateway作为Spring Cloud生态系统中的网关， 目标是替代Netflix Zuul，其不仅提供统一的路由方式， 并且还基于Filer链的方式提供了网关基本的功能， 例如：安全、监控/埋点、限流等。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:65:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud OpenFeign Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。 要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了， 不需要自己构建Http请求了，直接调用接口就行了， 不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:66:0","tags":["java"],"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["MySQL知识"],"content":"万能密码 原验证登陆语句: SELECT*FROMadminWHEREUsername='\".$username.\"'ANDPassword='\".md5($password).\"' 输入 1′ or 1=1 or ‘1’=’1万能密码语句变为: SELECT*FROMadminWHEREUsername='1'OR1=1OR'1'='1'ANDPassword='EDFKGMZDFSDFDSFRRQWERRFGGG' 即得到优先级关系：or\u003cand\u003cnot，同一优先级默认从左往右计算。 上面’1’=’1’ AND Password=’EDFKGMZDFSDFDSFRRQWERRFGGG’先计算肯定返回false,因为密码是我们乱输入的。(此处是假) Username=’1’ 返回假,没有用户名是1(此处是假) 1=1返回真(此处是真) 以上的结果是: 假 or 真 or 假 返回真。验证通过。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/sql%E6%B3%A8%E5%85%A5/:1:0","tags":["java"],"title":"Sql注入","uri":"https://hahaen.github.io/sql%E6%B3%A8%E5%85%A5/"},{"categories":["java知识"],"content":"什么是 SpringBoot？ Spring Boot 是 Spring 开源组织下的子项目， 是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度， 简省了繁重的配置，提供了各种启动器，使开发者能快速上手。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:1:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"为什么要用SpringBoot? 快速开发，快速整合，配置简化、内嵌服务容器 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:2:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot与SpringCloud的区别 SpringBoot是快速开发的Spring框架 SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:3:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot有哪些优点？ 容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。 开箱即用，远离繁琐的配置。 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。 SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:4:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？ 启动类上面的注解是@SpringBootApplication， 它也是Spring Boot 的核心注解，主要组合包含了以下 3 个注解： @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:5:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot Starter的工作原理 在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件, 该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件） ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:6:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？ 配置变更 JDK 版本升级 第三方类库升级 响应式 Spring 编程支持 HTTP/2 支持 配置属性绑定 更多改进与加强 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:7:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot支持什么前端模板? thymeleaf freemarker jsp，官方不推荐JSP会有限制 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:8:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot的缺点? 不用自己做的配置，报错时很难定位。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:9:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"运行 Spring Boot 有哪几种方式？ 打包用命令或者放到容器中运行 用 Maven/ Gradle 插件运行 直接执行 main 方法运行 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:10:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 需要独立的容器运行吗？ 可以不需要 内置了 Tomcat/ Jetty 等容器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:11:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"开启 Spring Boot 特性有哪几种方式？ 继承spring-boot-starter-parent项目 导入spring-boot-dependencies项目依赖 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:12:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot 实现热部署有哪几种方式？ 热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中 主要有两种方式： Spring Loaded Spring-boot-devtools ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:13:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot事物的使用 首先使用注解EnableTransactionManagement开启事物之后，然后在Service方法上添加注解Transactional便可。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:14:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Async异步调用方法 需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入@EnableAsync使异步调用@Async注解生效。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:15:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何在 Spring Boot 启动的时候运行一些特定的代码？ 可以实现接口 ApplicationRunner 或者 CommandLineRunner 这两个接口实现方式一样，它们都只提供了一个 run 方法 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:16:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 有哪几种读取配置的方式？ Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:17:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 JavaConfig？ Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他， 它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于： 面向对象的配置。由于配置被定义为 JavaConfig 中的类， 因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。 减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。 但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。 从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。 类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。 由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。 常用的Java config： @Configuration：在类上打上写下此注解，表示这个类是配置类 @ComponentScan：在配置类上添加 @ComponentScan 注解。 该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 \u003ccontext:component-scan \u003e。 @Bean：bean的注入：相当于以前的\u003c bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /\u003e @EnableWebMvc：相当于xml的\u003cmvc:annotation-driven \u003e @ImportResource： 相当于xml的 \u003c import resource=“applicationContext-cache.xml”\u003e ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:18:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot的自动配置原理是什么? 主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类， 有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。 有了这个EnableAutoConfiguration的话就会： 从配置文件META_INF/Spring.factories加载可能用到的自动配置类 去重，并将exclude和excludeName属性携带的类排除 过滤，将满足条件（@Conditional）的自动配置类返回 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:19:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"你如何理解 Spring Boot 配置加载顺序？ 在 Spring Boot 里面，可以使用以下几种方式来加载配置。 properties文件； YAML文件； 系统环境变量； 命令行参数； ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:20:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 YAML？ YAML 是一种人类可读的数据序列化语言。 它通常用于配置文件。 与属性文件相比，如果我们想要在配置文件中添加复杂的属性， YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:21:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"YAML 配置的优势在哪里 ? YAML 现在可以算是非常流行的一种配置文件格式了， 无论是前端还是后端，都可以见到 YAML 配置。 那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？ 配置有序，在一些特殊的场景下，配置有序很关键 简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象 相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:22:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 是否可以使用 XML 配置 ? Spring Boot 推荐使用 Java 配置而非 XML 配置， 但是 Spring Boot 中也可以使用 XML 配置， 通过 @ImportResource 注解可以引入一个 XML 配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:23:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ? 单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件， 但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。 spring boot 核心的两个配置文件： bootstrap (. yml 或者 . properties)： boostrap 由父 ApplicationContext 加载的， 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。 一般来说我们在 Spring Cloud 配置就会使用这个文件。 且 boostrap 里面的属性不能被覆盖； application (. yml 或者 . properties)： 由ApplicatonContext 加载， 用于 spring boot 项目的自动化配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:24:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 Spring Profiles？ 在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的， 例如数据库连接、redis的配置等等。 那我们如何在不同环境中自动实现配置的切换呢？ Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能 Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。 因此，当应用程序在开发中运行时，只有某些 bean 可以加载， 而在 PRODUCTION中，某些其他 bean 可以加载。 假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。 这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:25:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot多数据源拆分的思路？ 先在properties配置文件中配置两个数据源，创建分包mapper， 使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:26:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot多数据源事务如何管理 第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务 第二种是使用jta-atomikos实现分布式事务管理 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:27:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"保护 Spring Boot 应用有哪些方法？ 在生产中使用HTTPS 使用Snyk检查你的依赖关系 升级到最新版本 启用CSRF保护 使用内容安全策略防止XSS攻击 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:28:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何实现 Spring Boot 应用程序的安全性？ 为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项， 并且必须添加安全配置。它只需要很少的代码。 配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:29:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"比较一下 Spring Security 和 Shiro 各自的优缺点 ? 由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ， 使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口， 所以，如果是 Spring Boot 项目，一般选择 Spring Security 。 当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。 Shiro 和 Spring Security 相比，主要有如下一些特点： Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单 Spring Security 功能强大；Shiro 功能简单 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:30:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中如何解决跨域问题 ? 跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求， 在 RESTful 风格的应用中，就显得非常鸡肋， 因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。 这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中， 就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ， 现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\") .maxAge(3600); } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:31:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中的监视器是什么？ Spring boot actuator 是 spring 启动框架中的重要功能之一。 Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。 有几个指标必须在生产环境中进行检查和监控。 即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。 监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:32:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何使用 Spring Boot 实现全局异常处理？ Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:33:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"我们如何监视所有 Spring Boot 微服务？ Spring Boot 提供监视器端点以监控各个微服务的度量。 这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。 但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。 想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。 为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI， 使我们能够可视化多个应用程序的度量。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:34:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot性能如何优化? 如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围 在项目启动时设置JVM初始内存和最大内存相同 将springboot内置服务器由tomcat设置为undertow ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:35:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？ 这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。 Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。 Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。 开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。 这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。 这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。 它还提供 H2 数据库控制台以更好地测试应用程序。 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:36:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot微服务中如何实现 session 共享 ? 在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上， 各自的 session 被从物理空间上隔离开了， 但是经常，我们需要在不同微服务之间共享 session ， 常见的方案就是 Spring Session + Redis 来实现 session 共享。 将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时， 都去操作 Redis 上的 session 。这样就实现了 session 共享， Spring Session 基于 Spring 中的代理过滤器实现， 使得 session 的同步操作对开发人员而言是透明的，非常简便。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:37:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"您使用了哪些 starter maven 依赖项？ 使用了下面的一些依赖项 spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持 spring-boot-starter-data-jpa 数据库支持 spring-boot-starter-data-redis redis数据库支持 spring-boot-starter-data-solr solr支持 mybatis-spring-boot-starter 第三方的mybatis集成starter ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:38:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中的 starter 到底是什么 ? 首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。 首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ， 在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的）， 然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置， 然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来， 新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。 当然，开发者也可以自定义 Starter ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:39:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中如何实现定时任务 ? 在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解， 另一个则是使用第三方框架 Quartz。 使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:40:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"spring-boot-starter-parent 有什么用 ? 总结就是打包用的 我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的， 这个 parent 就是 spring-boot-starter-parent ， spring-boot-starter-parent 主要有如下作用： 定义了 Java 编译版本为 1.8 。 使用 UTF-8 格式编码。 继承自 spring-boot-dependencies，这个里边定义了依赖的版本， 也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。 执行打包操作的配置。 自动化的资源过滤。 自动化的插件配置。 针对 application.properties 和 application.yml 的资源过滤， 包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:41:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot如何实现打包 进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包 或者点击左边选项栏中的Mavne，先点击clean在点击package ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:42:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 打成的 jar 和普通的 jar 有什么区别 ? Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行， 这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。 Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。 普通的 jar 包，解压后直接就是包名，包里就是我们的代码， 而 Spring Boot 打包成的可执行 jar 解压后，在 \\BOOT-INF\\classes 目录下才是我们的代码， 因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置， 将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:43:0","tags":["java"],"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是SpringMVC? SpringMVC是一种基于 Java 的实现MVC设计模型的请求驱动类型的轻量级Web框架， 属于Spring框架的一个模块。 它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。 同时它还支持restful编程风格的请求。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:1:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"什么是MVC模式？ MVC的全名是Model View Controller 是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。 它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面， 在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。 M即model模型是指模型表示业务规则。 在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的， 模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 V即View视图是指用户看到并与之交互的界面。 比如由html元素组成的网页界面，或者软件的客户端界面。 MVC的好处之一在于它能为应用程序处理很多不同的视图。 在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求， 控制器本身不输出任何东西和做任何处理。 它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:2:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC的执行流程？ 用户点击某个请求路径，发起一个request请求，此请求会被前端控制器处理。 前端控制器请求处理器映射器去查找Handler。可以依据注解或者XML配置去查找。 处理器映射器根据配置找到相应的Handler(可能包含若干个Interceptor拦截器)，返回给前端控制器。 前端控制器请求处理器适配器去执行相应的Handler处理器（常称为Controller）。 处理器适配器执行Handler处理器。 Handler处理器执行完毕之后会返回给处理器适配器一个ModelAndView对象（SpringMVC底层对象， 包括Model数据模型和View视图信息）。 处理器适配器接收到Handler处理器返回的ModelAndView后，将其返回给前端控制器。 前端控制器接收到ModelAndView后，会请求视图解析器（ViewResolver）对视图进行解析。 视图解析器根据View信息匹配到相应的视图结果，反馈给前端控制器。 前端控制器收到View具体视图后，进行视图渲染， 将Model中的模型数据填充到View视图中的request域，生成最终的视图(View)。 前端控制器向用户返回请求结果。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:3:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC有哪些优点？ SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。 SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式， 减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。 支持灵活的URL到页面控制器的映射。 可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。 由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。 拥有十分简洁的异常处理机制。 可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。 支持RestFul风格。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:4:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"Spring MVC的主要组件？ 前端控制器：其作用是接收用户请求，然后给用户反馈结果。 它的作用相当于一个转发器或中央处理器，控制整个流程的执行， 对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。 处理器映射器：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。 处理器适配器：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。 处理器：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。 视图解析器：其作用是进行解析操作， 通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。 视图：View是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等）。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:5:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC和Struts2的区别有哪些? SpringMVC的入口是一个Servlet，也就是前端控制器(DispatcherServlet)， 而Struts2的入口是一个Filter (StrutsPrepareAndExecuteFilter)。 SpringMVC是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参， 可以设计为单例或多例(建议单例)。struts2是基于类开发，请求参数传递到类的成员属性，只能设计为多例。 SpringMVC通过参数解析器将request请求内容解析，并给方法形参赋值， 将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用JSTL。Struts2采用值栈存储请求和响应的数据，通过OGNL存取数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:6:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC怎么样设定重定向和请求转发？ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"请求转发与重定向的区别 请求转发在服务器端完成的；重定向是在客户端完成的。 请求转发的速度快；重定向速度慢。 请求转发的是同一次请求；重定向是两次不同请求。 请求转发不会执行转发后的代码；重定向会执行重定向之后的代码。 请求转发地址栏没有变化；重定向地址栏有变化。 请求转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:1","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC设定请求转发 在返回值前面加\"forward:\" @RequestParam(\"/login\") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，转发到登录页面 return \"forward:tologin\"; } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:2","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC设定重定向 在返回值前面加\"redirect:\"。例如我们在登录的时候，登录失败会重定向到登录页面。 @RequestParam(\"/login\") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，重定向到登录页面 return \"redirect:tologin\"; } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:3","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？ Controller是单例模式，在多线程访问的时候可能产生线程安全问题，不要使用同步，会影响程序性能。 解决方案是在控制器里面不能编写成员属性。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:8:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC常用的注解有哪些？ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@Controller @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。 处理器适配器将会扫描使用了该注解的类的方法， 并检测该方法是否使用了@RequestMapping注解。 @Controller只是定义了一个控制器类， 而使用@RequestMapping注解的方法才是真正处理请求的处理器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:1","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@RequsestMapping @RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 返回值会通过视图解析器解析为实际的物理视图， 对于 InternalResourceViewResolver 视图解析器， 通过 prefix + returnValue + suffix 这样的方式得到实际的物理视图， 然后做转发操作。 \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e @RequsestMapping有如下6个属性 value：指定请求的实际地址。 method：指定请求的method类型， GET、POST、PUT、DELETE等。 consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params：指定request中必须包含某些参数值是，才让该方法处理。 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:2","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ResponseBody @ResponseBody把Java对象转化为json对象，这种方式用于Ajax异步请求， 返回的不是一个页面而是JSON格式的数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:3","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@Valid 标志参数被Hibernate-Validator校验框架校验。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:4","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@PathVariable @PathVariable用于接收uri地址传过来的参数，Url中可以通过一个或多个{Xxx}占位符映射， 通过@PathVariable可以绑定占位符参数到方法参数中，在RestFul接口风格中经常使用。 例如：请求URL：http://localhost/user/21/张三/query (Long类型可以根据需求改变为String或int，SpringMVC会自动做转换) @RequestMapping(\"/user/{userId}/{userName}/query\") public User query(@PathVariable(\"userId\") Long userId, @PathVariable(\"userName\") String userName){ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:5","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@RequestParam @RequestParam用于将请求参数映射到控制器方法的形参上，有如下三个属性 value：参数名。 required：是否必需，默认为true，表示请求参数中必须包含该参数，如果不包含抛出异常。 defaultValue：默认参数值，如果设置了该值自动将required设置为false， 如果参数中没有包含该参数则使用默认值。 示例：@RequestParam(value = “pageNum”, required = false, defaultValue = “1”) ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:6","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ControllerAdvice @ControllerAdvice标识一个类是全局异常处理类。 @ControllerAdvice public class ControllerTest { //全局异常处理类 } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:7","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ExceptionHandler @ExceptionHandler标识一个方法为全局异常处理的方法。 @ExceptionHandler public void ExceptionHandler(){ //全局异常处理逻辑... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:8","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？ 一般使用@Controller注解标识控制器。 也可以使用@RestController注解替代@Controller注解， @RestController相当于@ResponseBody＋@Controller， 表示控制器中所有的方法都返回JSON格式数据，一般不使用其他注解标识控制器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:10:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"如果在拦截请求中，想拦截get方式提交的方法,怎么配置？ 可以在@RequestMapping注解里面加上method=RequestMethod.GET。 @RequestMapping(value=\"/toLogin\",method = RequestMethod.GET) public ModelAndView toLogin(){} 可以使用@GetMapping注解。 @GetMapping(value=\"/toLogin\") public ModelAndView toLogin(){} ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:11:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"怎样在控制器方法里面得到request或者session？ 直接在控制器方法的形参中声明request，session，SpringMvc就会自动把它们注入。 @RequestMapping(\"/login\") public ModelAndView login(HttpServletRequest request, HttpSession session){ } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:12:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？ 直接在控制器方法的形参里面声明这个参数就可以，但名字必须和传过来的参数名称一样，否则参数映射失败。 下面方法形参中的userId，就会接收从前端传来参数名称为userId的值。 @RequestMapping(\"/deleteUser\") public void deleteUser(Long userId){ //删除用户操作... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:13:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"前台传入多个参数,并且这些参数都是一个对象的属性,怎么进行参数绑定？ 直接在控制器方法的形参里面声明这个参数就可以，SpringMvc就会自动会请求参数赋值到这个对象的属性中。 下面方法形参中的user用来接收从前端传来的多个参数，参数名称需要和User实体类属性名称一致。 @RequestMapping(\"/saveUser\") public void saveUser(User user){ //保存用户操作... } @Data public class User { private Long userId; private String username; private String password; //... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:14:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC用什么对象从后台向前台传递数据的？ 使用Map、Model和ModelMap的方式，这种方式存储的数据是在request域中 @RequestMapping(\"/getUser\") public String getUser(Map\u003cString,Object\u003e map,Model model,ModelMap modelMap){ //1.放在map里 map.put(\"name\", \"xq\"); //2.放在model里，一般是使用这个 model.addAttribute(\"habbit\", \"Play\"); //3.放在modelMap中 modelMap.addAttribute(\"city\", \"gd\"); modelMap.put(\"gender\", \"male\"); return \"userDetail\"; } 使用request的方式 @RequestMapping(\"/getUser\") public String getUser(Map\u003cString,Object\u003e map,Model model,ModelMap modelMap,HttpServletRequest request){ //放在request里 request.setAttribute(\"user\", userService.getUser()); return \"userDetail\"; } 使用ModelAndView @RequestMapping(\"/getUser\") public ModelAndView getUser(ModelAndView modelAndView) { mav.addObject(\"user\", userService.getUser()); mav.setViewName(\"userDetail\"); return modelAndView; } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:15:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"怎么样把ModelMap里面的数据放入session里面？ 在类上添加@SessionAttributes注解将指定的Model数据存储到session中。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@SessionAttributes 默认情况下Spring MVC将模型中的数据存储到request域中。 当一个请求结束后，数据就失效了。如果要跨页面使用。 那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。 @SessionAttributes只能定义在Class,interface enum上， 作用是将指定的Model中的键值对添加至session中，方便在一个会话中使用。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:1","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@SessionAttributes参数 names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中。 value：其实和上面的names是一样的。 @SessionAttributes(value={\"names\"},types={Integer.class}) @Controller public class session{ @RequestMapping(\"/session\") public String session(Model model){ model.addAttributes(\"names\", Arrays.asList(\"caoyc\",\"zhh\",\"cjx\")); model.addAttributes(\"age\", 22); return \"/session\"; } } 在类上添加@SessionAttributes注解，并指定将names名称的Model数据存储到session域中， 以及将Integer类型的Model数据存储到session域中。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:2","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC中有个类把视图和数据都合并的一起的,叫什么？ 它就是ModelAndView。 使用ModelAndView类存储处理完后的结果数据，以及显示该数据的视图。 从名字上看ModelAndView中的Model代表模型，View代表视图，从名字看就很好地解释了该类的作用。 Controller处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中， 把要返回的视图信息存储在该类的view属性中，然后把ModelAndView返回给前端控制器。 前端控制器通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。 返回指定页面: ModelAndView构造方法可以指定返回的页面名称。 也可以通过setViewName()方法跳转到指定的页面 。 返回所需数值: 使用addObject()设置需要返回的值， addObject()有几个不同参数的方法，可以默认和指定返回对象的名字。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:17:0","tags":["java"],"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":" 前序遍历：根 —\u003e 左 —\u003e 右 中序遍历：左—\u003e 根 —\u003e 右 后序遍历：左 —\u003e 右 —\u003e 根 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:0:0","tags":["java"],"title":"二叉树遍历","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"前序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:0:1","tags":["java"],"title":"二叉树遍历","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"中序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:0:2","tags":["java"],"title":"二叉树遍历","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"后序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:0:3","tags":["java"],"title":"二叉树遍历","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"层序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:0:4","tags":["java"],"title":"二叉树遍历","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"复杂度 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:0","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"冒泡排序 冒泡排序 基本原理： 对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较， 当前面的记录大于后面的记录时，交换位置， 进行一轮比较和换位后，n个记录中的最大记录将位于第n位； 然后对前(n-1)个记录进行第二轮比较；重复该过程直到进行比较的记录只剩下一个为止。 public class BubbleSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i \u003c arr.length; i++) { // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j \u003c arr.length - i; j++) { if (arr[j] \u003e arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:1","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"选择排序 选择排序 基本原理： 对于给定的一组记录，经过第一轮比较后得到最小的记录， 然后将该记录与第一个记录的位置进行交换； 接着对不包括第一个记录以外的其他记录进行第二次比较， 得到最小的记录并与第二个记录进行位置交换； 重复该过程，直到进行比较的记录只有一个为止。 public class SelectionSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i \u003c arr.length - 1; i++) { int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j \u003c arr.length; j++) { if (arr[j] \u003c arr[min]) { // 记录目前能找到的最小值元素的下标 min = j; } } // 将找到的最小值和i位置所在的值进行交换 if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:2","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"插入排序 插入排序 基本原理： 对于给定的一组数据，初始时假设第一个记录自成一个有序序列， 其余记录为无序序列。接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中， 直至最后一个记录插入到有序序列中为止。 public class InsertSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i \u003c arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j \u003e 0 \u0026\u0026 tmp \u003c arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:3","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"希尔排序 希尔排序 基本原理： 先将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对减少， 然后对各个子序列分别进行直接插入排序，待整个待排序序列\"基本有序后\"， 最后再对所有元素进行一次直接插入排序。 public static void shellSort(int[] arr) { int length = arr.length; int temp; for (int step = length / 2; step \u003e= 1; step /= 2) { for (int i = step; i \u003c length; i++) { temp = arr[i]; int j = i - step; while (j \u003e= 0 \u0026\u0026 arr[j] \u003e temp) { arr[j + step] = arr[j]; j -= step; } arr[j + step] = temp; } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:4","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"归并排序 归并排序 基本原理： 利用递归与分治技术将数据序列划分成为越来越小的半子表， 再对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。 对于给定的一组记录(假设共有n个记录)， 首先将每两个相邻的长度为1的子序列进行归并， 得到n/2(向上取整)个长度为2或1的有序子序列， 再将其两两归并，反复执行此过程，直到得到一个有序序列。 public class MergeSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length \u003c 2) { return arr; } int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); } protected int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; int i = 0; while (left.length \u003e 0 \u0026\u0026 right.length \u003e 0) { if (left[0] \u003c= right[0]) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } else { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } } while (left.length \u003e 0) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } while (right.length \u003e 0) { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } return result; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:5","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"快速排序 快速排序 基本原理： 对于一组给定的记录，通过一趟排序后，将原序列分为两部分， 其中前一部分的所有记录均比后一部分的所有记录小， 然后再依次对前后两部分的记录进行快速排序， 递归该过程，直到序列中的所有记录均有序为止。 public class QuickSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); } private int[] quickSort(int[] arr, int left, int right) { if (left \u003c right) { int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); } return arr; } private int partition(int[] arr, int left, int right) { // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i \u003c= right; i++) { if (arr[i] \u003c arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index - 1; } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:6","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"堆排序 堆排序 基本原理： 对于给定的n个记录，初始时把这些记录看作一颗顺序存储的二叉树， 然后将其调整为一个小顶堆，然后将堆的最后一个元素与堆顶元素进行交换后， 堆的最后一个元素即为最小记录；接着讲前(n-1)个元素重新调整为一个小顶堆， 再将堆顶元素与当前堆的最后一个元素进行交换后得到次小的记录， 重复该过程直到调整的堆中只剩一个元素时为止，该元素即为最大记录， 此时可得到一个有序序列。 public class HeapSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i \u003e 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } return arr; } private void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i \u003e= 0; i--) { heapify(arr, i, len); } } private void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left \u003c len \u0026\u0026 arr[left] \u003e arr[largest]) { largest = left; } if (right \u003c len \u0026\u0026 arr[right] \u003e arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:7","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"计数排序 计数排序 基本原理： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 public class CountingSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); } private int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j \u003c bucketLen; j++) { while (bucket[j] \u003e 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u003c value) { maxValue = value; } } return maxValue; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:8","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"桶排序 桶排序 基本原理： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 public class BucketSort implements IArraySort { private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); } private int[] bucketSort(int[] arr, int bucketSize) throws Exception { if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value \u003c minValue) { minValue = value; } else if (value \u003e maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i \u003c arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length \u003c= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } return arr; } /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:9","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"基数排序 基数排序 基本原理： 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 /** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */ public class RadixSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); } /** * 获取最高位数 */ private int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u003c value) { maxValue = value; } } return maxValue; } protected int getNumLenght(long num) { if (num == 0) { return 1; } int lenght = 0; for (long temp = num; temp != 0; temp /= 10) { lenght++; } return lenght; } private int[] radixSort(int[] arr, int maxDigit) { int mod = 10; int dev = 1; for (int i = 0; i \u003c maxDigit; i++, dev *= 10, mod *= 10) { // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j \u003c arr.length; j++) { int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); } int pos = 0; for (int[] bucket : counter) { for (int value : bucket) { arr[pos++] = value; } } } return arr; } /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:10","tags":["java"],"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["MySQL知识"],"content":" left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。 right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。 inner join（内连接）：只返回两个表中连接字段相等的行。 full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。 A表idname1小王2小李3小刘 B表idA_idjob12老师24程序员 左连接：（左边的表不加限制） selecta.name,b.jobfromAaleftjoinBbona.id=b.A_id 返回结果 三条记录小王null小李老师小刘null 右连接：（右边的表不加限制） selecta.name,b.jobfromAarightjoinBbona.id=b.A_id 返回结果 两条记录小李老师null程序员 内连接：（只有2张表匹配的行才能显示） selecta.name,b.jobfromAainnerjoinBbona.id=b.A_id 返回结果 只能得到一条记录小李老师 全外连接：(左右2张表都不加限制） selecta.name,b.jobfromAafulljoinBbona.id=b.A_id 四条数据小王null小李老师小刘nullnull程序员 ","date":"2022-03-11","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A6%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5/:0:0","tags":["java"],"title":"数据库左连接内连接","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A6%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5/"},{"categories":["java知识"],"content":"封装 封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/:0:1","tags":["java"],"title":"Java面向对象三大特性封装继承多态","uri":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"},{"categories":["java知识"],"content":"继承 继承是使⽤已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能, 也可以⽤⽗类的功能，但不能选择性地继承⽗类。通过使⽤继承我们能够⾮常⽅便地复⽤以前的代码。 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/:0:2","tags":["java"],"title":"Java面向对象三大特性封装继承多态","uri":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"},{"categories":["java知识"],"content":"多态 多态是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定， 即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。 在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/:0:3","tags":["java"],"title":"Java面向对象三大特性封装继承多态","uri":"https://hahaen.github.io/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"},{"categories":["MySQL知识"],"content":"where(条件) select*frompersonwherename='yang'\u0026\u0026age=22; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"like(搜索查询) 搜索查询，或者说模糊匹配，表达式主要涉及到两个符号： 百分号 %：匹配任意多个字符 下划线 _：匹配固定一个字符 例如： 查询所有的数据，找到其中 name 字段以字符「ang」结尾的数据记录集合： select*frompersonwherenamelike'%ang'; 查询所有的数据，找到其中 name 字段以字符「ang」结尾，并且前面还有一个任意字符的数据记录集合： select*frompersonwherenamelike'_ang'; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:2:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"in(集合) in 关键字也是使用在 where 子句的条件表达式中，它限制的是一个集合，只要字段的值在集合中即符合条件 例如： 查询出来所有年龄是 22,30,23 的人数据记录 select*frompersonwhereagein(22,30,23); not in 反向限制 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:3:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"order by(排列) order by子句根据一列或者多列的值，按照升序或者降序排列数据。 asc表示数据结果集按升序排序，desc表示数据结果集按降序排序。 例子： 数据参照 id 列，倒序排序 select*frompersonorderbyiddesc; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:4:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"group by(分组) group by子句用于将查询返回的结果集进行一个分组，并展示各个分组中排在第一个的记录，将分组中其余成员隐藏。 例如： 按照姓名对结果集进行分组,分组之后，只展示每个分组下排序第一的记录，其余成员隐藏。 select*frompersongroupbyname; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:5:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"having(排序) having子句在我看来就是一个高配版的where子句，无论是我们的分组或是排序， 都是基于以返回的结果集，也就是说where子句的筛选已经结束。 例如： 对排序、分组后的数据集依然有筛选需求，就用到我们的having子句 selectavg(age)asvagefrompersongroupbynamehavingvage\u003e23; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:6:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"between(两个数值之间) 在where中使用between表示一个数在两个数值之间取值 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:7:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"distinct(表示将distinct后的属性去重) 去掉重复的关键字 selectdistinct列名from表名-- order by ：排序 -- desc 降序(默认升序) -- asc 升序 select列名from表名orderby列名1desc，列名2asc ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:8:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"as(别名) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:9:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"avg(平均) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:10:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"min(最小值) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:11:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"max(最大值) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:12:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"sum(总和) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:13:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"count(计数) ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:14:0","tags":["java"],"title":"数据库关键字","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"创建 USER表 PRIMARY KEY 主键 AUTO_INCREMENT AUTO_INCREMENT就可以从小到大自动生成 UNIQUE 约束唯一标识数据库表中的每条记录 ENGINE = InnoDB 存储引擎是innodb DEFAULT CHARSET = utf8mb4 修改字符集 COLLATE = utf8mb4_unicode_ci 排序的规则 CREATETABLEUSER(IDBIGINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(100),TELVARCHAR(20)UNIQUE,AVATAR_URLVARCHAR(1024),ADDRESSVARCHAR(1024),CREATED_ATTIMESTAMPNOTNULLDEFAULTNOW(),UPDATED_ATTIMESTAMPNOTNULLDEFAULTNOW())ENGINE=InnoDBDEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci; 增 INSERT[INTO]表名[(字段列表)]VALUES(值列表)[,(值列表),...]-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE与INSERT完全一样，可互换。INSERT[INTO]表名SET字段名=值[,字段名=值,...] 例子： insertintoperson(id,name,age,phone,address)values(1,'yang',22,'123232323','中国上海'); 删 DELETEFROM表名[删除条件子句]没有条件子句，则会删除全部 例子： deletefrompersonwhereid=1; 改 UPDATE表名SET字段名=新值[,字段名=新值][更新条件] 例子： updatepersonsetaddress='浙江杭州'; 查 SELECT字段列表FROM表名[其他子句]-- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 例子： select*FROMperson; ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/:0:0","tags":["java"],"title":"数据增删改查","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"categories":["MySQL知识"],"content":"用法不同 drop(丢弃数据):drop table表名 ，直接将表都删除掉，在删除表的时候使用。 delete（删除数据）:delete from 表名 where 列名=值，删除某一列的数据 不带where子句的delete、以及drop都会删除表内的数据 但是delete只删除数据不删除表的结构(定义) 执行drop语句，此表的结构也会删除，也就是执行drop之后对应的表不复存在。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/dropdelete%E5%8C%BA%E5%88%AB/:0:1","tags":["java"],"title":"Drop、delete区别？","uri":"https://hahaen.github.io/dropdelete%E5%8C%BA%E5%88%AB/"},{"categories":["MySQL知识"],"content":" 主键(主码) ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。 外键(外码) ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["java"],"title":"数据库主键和外键的区别","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":" override是重写,重写是一种动态绑定的多态机制。 overload是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的多态机制。 @Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处: 可以当注释用,方便阅读； 编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%9C%E7%94%A8/:0:0","tags":["java"],"title":"重写和重载的作用？","uri":"https://hahaen.github.io/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%9C%E7%94%A8/"},{"categories":["java知识"],"content":" 因为两个相等的对象的hashCode值必须是相等。 也就是说如果equals方法判断两个对象是相等的，那这两个对象的hashCode值也要相等。 如果重写equals()时没有重写hashCode()方法的话就可能会导致equals方法判断是相等的两个对象,hashCode值却不相等。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/:0:0","tags":["java"],"title":"为什么重写equals时必须重写hashCode方法？","uri":"https://hahaen.github.io/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/"},{"categories":["java知识"],"content":"调用方式 在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象.方法名的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 不过，需要注意的是一般不建议使用对象.方法名的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。 因此，一般建议使用类名.方法名的方式来调用静态方法。 public class Person { public void method() { //...... } public static void staicMethod(){ //...... } public static void main(String[] args) { Person person = new Person(); // 调用实例方法 person.method(); // 调用静态方法 Person.staicMethod() } } ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/:0:1","tags":["java"],"title":"静态方法和实例方法有何不同？","uri":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/"},{"categories":["java知识"],"content":"访问类成员是否存在限制 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/:0:2","tags":["java"],"title":"静态方法和实例方法有何不同？","uri":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/"},{"categories":["java知识"],"content":" 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:0:0","tags":["java"],"title":"静态方法为什么不能调用非静态方法？","uri":"https://hahaen.github.io/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["java知识"],"content":"在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。 但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环， 这就需要用到下面几个关键词： continue：指跳出当前的这一次循环，继续下一次循环。 break：指跳出整个循环体，继续执行循环下面的语句。 return：用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 下列语句的运行结果是什么？ public static void main(String[] args) { boolean flag = false; for (int i = 0; i \u003c= 3; i++) { if (i == 0) { System.out.println(\"0\"); } else if (i == 1) { System.out.println(\"1\"); continue; } else if (i == 2) { System.out.println(\"2\"); flag = true; } else if (i == 3) { System.out.println(\"3\"); break; } else if (i == 4) { System.out.println(\"4\"); } System.out.println(\"xixi\"); } if (flag) { System.out.println(\"haha\"); return; } System.out.println(\"heihei\"); } 运行结果: 0 xixi 1 2 xixi 3 haha ","date":"2022-03-10","objectID":"https://hahaen.github.io/continuebreak%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/:0:0","tags":["java"],"title":"Continue、break和return的区别是什么？","uri":"https://hahaen.github.io/continuebreak%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["java知识"],"content":" ++ 和 – 运算符可以放在变量之前，也可以放在变量之后 当运算符放在变量之前时(前缀)，先自增/减，再赋值 ++a 当运算符放在变量之后时(后缀)，先赋值，再自增/减 a-- 例如 当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b） 当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1） ++a 输出的是 a+1 的值，a++输出的是 a 值 “符号在前就先加/减，符号在后就后加/减” ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["java"],"title":"自增运算符++和自减运算符  ","uri":"https://hahaen.github.io/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["java知识"],"content":"异常基本类型 异常类的基本类型是Throwable类 两大子类分别是Error和Exception ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:1:0","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"Error 系统错误由Java虚拟机抛出，用Error类表示。Error类描述的是内部系统错误 例如：Java虚拟机崩溃。在程序中不会对Error异常进行捕捉和抛出。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:1:1","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"Exception 异常Exception又分为RuntimeException(运行时异常)和CheckedException(检查时异常) RuntimeException(运行时异常) 程序运行过程中才可能发生的异常,一般为代码的逻辑错误 例如：类型错误转换，空指针异常、找不到指定类等 CheckedException(检查时异常) 编译期间可以检查到的异常，必须显式的进行处理（捕获或者抛出到上一层） 例如：IOException, FileNotFoundException,SQLException等 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:1:2","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"异常处理 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:2:0","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"throws（声明异常） 在方法头中显式声明该异常，以便于告知方法调用者此方法有异常 若父类的方法没有声明异常，则子类继承方法后，也不能声明异常 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:2:1","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"try-catch（捕获异常） 若执行try块的过程中没有发生异常，则跳过catch子句 若是出现异常，try块中剩余语句不再执行。 再判断catch块的异常类是否是捕获的异常类型，匹配后执行相应的catch块中的代码。 如果有finally的话进入到finally里面继续执行。 try ctach fianally中有return时，会先执行return,但是不会返回。在执行完finally后进行返回 catch语句可以有一个或多个，finally语句最多一个 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:2:2","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"throw,throws关键字区别 throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常 public static void test()throws Exception{ throw new Exception(\"方法test中的Exception\"); } ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/:3:0","tags":["java"],"title":"Java异常","uri":"https://hahaen.github.io/java%E5%BC%82%E5%B8%B8/"},{"categories":["java知识"],"content":"在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类 当用final修饰一个类时，表明这个类不能被继承。 修饰方法 如果只有在想明确禁止,该方法在子类中被覆盖的情况下才将方法设置为final的。 即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。 修饰变量 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化； 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。 final修饰一个成员变量（属性），必须要显示初始化。 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/final%E7%9A%84%E4%BD%9C%E7%94%A8/:0:0","tags":["java"],"title":"Final的作用？","uri":"https://hahaen.github.io/final%E7%9A%84%E4%BD%9C%E7%94%A8/"},{"categories":["java知识"],"content":" 如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本； 如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口； 如果要设计大的功能单元，则使用抽象类。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类； 抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%88%96%E6%8A%BD%E8%B1%A1%E7%B1%BB/:0:0","tags":["java"],"title":"什么时候用接口或抽象类？","uri":"https://hahaen.github.io/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%88%96%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["java知识"],"content":" Interface(接口):定义功能，只能包含方法(实现),不能包含成员变量，可以被实现若干次。 Abstract class(抽象类):定义抽象的骨架实现，可以包含抽象方法或者实现，也可以包含成员变量，只能沿着一条路径继承。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%ABor%E8%81%94%E7%B3%BB/:0:0","tags":["java"],"title":"接口和抽象类有什么区别or联系？","uri":"https://hahaen.github.io/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%ABor%E8%81%94%E7%B3%BB/"},{"categories":["java知识"],"content":" 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["java"],"title":"深拷贝、浅拷贝的区别？","uri":"https://hahaen.github.io/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":" 对象类型不同 equals()：是超类Object中的方法。 ==：是操作符。 比较的对象不同 equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。 ==：用于比较引用和比较基本数据类型时具有不同的功能 运行速度不同 equals()：没有==运行速度快。 ==：运行速度比equals()快，因为==只是比较引用。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/equals%E5%8C%BA%E5%88%AB/:0:0","tags":["java"],"title":"==、Equals区别？","uri":"https://hahaen.github.io/equals%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":"常用方法： indexOf() 返回指定字符的索引。 charAt() 返回指定索引处的字符。 replace() 字符串替换。 trim() 去除字符串两端空白。 split() 分割字符串，返回一个分割后的字符串数组。 getBytes() 返回字符串的 byte 类型数组。 length() 返回字符串长度。 toLowerCase() 将字符串转成小写字母。 toUpperCase() 将字符串转成大写字符。 substring() 截取字符串。 equals() 字符串比较。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/string%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/:0:0","tags":["java"],"title":"String中有哪些方法？","uri":"https://hahaen.github.io/string%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/"},{"categories":["java知识"],"content":" Object类，属于java.lang包，位于类层次结构树的顶部。 每个类都是Object类的直接或间接的后代。 使用或编写的每个类都继承Object的实例方法。 常用方法： getClass 方法 final 方法、获取对象的运行时 class 对象，class 对象就是描述对象所属类的对象。 hashCode 方法 该方法主要用于获取对象的散列值。Object 中该方法默认返回的是对象的堆内存地址。 equals 方法 该方法用于比较两个对象，如果这两个对象引用指向的是同一个对象，那么返回 true，否则返回 false。 clone 方法 该方法是保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。 toString 方法 返回一个 String 对象，一般子类都有覆盖。默认返回格式如下：对象的 class 名称 + @ + hashCode 的十六进制字符串。 wait 方法 当timeout 为 0，即不等待。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/object%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/:0:0","tags":["java"],"title":"Object有哪些方法？","uri":"https://hahaen.github.io/object%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/"},{"categories":["java知识"],"content":"区别 StringBuffer更快，但线程不安全，常用 StringBuilder稍慢，但线程安全 ","date":"2022-03-10","objectID":"https://hahaen.github.io/stringbufferstringbuilder%E5%8C%BA%E5%88%AB/:0:1","tags":["java"],"title":"StringBuffer、StringBuilder区别","uri":"https://hahaen.github.io/stringbufferstringbuilder%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":"线程安全性 如果没有额外声明，所有类的默认都是线程不安全的 ","date":"2022-03-10","objectID":"https://hahaen.github.io/stringbufferstringbuilder%E5%8C%BA%E5%88%AB/:0:2","tags":["java"],"title":"StringBuffer、StringBuilder区别","uri":"https://hahaen.github.io/stringbufferstringbuilder%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":" Java世界中的一切对象都是指针(地址) 函数调用永远是传值 基本类型（包括String类）作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的 引用类型（包括数组，对象以及接口）作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。 注意：基本数据类型的封装类Integer、Short、Float、Double、Long、Boolean、Byte、Character虽然是引用类型，但它们在作为参数传递时，也和基本数据类型一样，是值传递。 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/:0:0","tags":["java"],"title":"Java的参数传递是传值还是传引用？","uri":"https://hahaen.github.io/java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/"},{"categories":["java知识"],"content":"基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean String是基本数据类型吗？答：不是 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/:0:0","tags":["java"],"title":"Java的基本类型","uri":"https://hahaen.github.io/java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"},{"categories":["java知识"],"content":"JDK=JRE+javac javac 相当于 编译compler jdk java开发工具包,java语言编写的程序所需的开发工具包 jre java运行时环境,即java程序的运行时环境，包含了java虚拟机，java基础类库 jdk包含jre,jre是java运行时环境，另外jdk包含开发时所需要的sdk和编译器javac和javadoc工具 ","date":"2022-03-10","objectID":"https://hahaen.github.io/jdkjre%E5%8C%BA%E5%88%AB/:0:0","tags":["java"],"title":"JDK、JRE区别","uri":"https://hahaen.github.io/jdkjre%E5%8C%BA%E5%88%AB/"},{"categories":["java知识"],"content":".java — 编译(compler) — 字节码(.class) — JVM .class 打包成 .jar JVM解析字节码 使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java 通过编译 .java 文件，生成同名的 .class 字节码文件 通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/:0:0","tags":["java"],"title":"Java程序的运行原理","uri":"https://hahaen.github.io/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"生命周期(lifecycle) default生命周期处理项目部署 clean生命周期处理项目清理 site生命周期处理项目站点文档的创建 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:1:0","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["java知识"],"content":"阶段(phase) 每个构建生命周期都由不同的构建阶段列表定义，其中构建阶段表示生命周期中的一个阶段。 例如，default生命周期包括以下阶段： validate - 验证项目是否正确，并提供所有必要的信息 compile - 编译项目源代码 test - 使用合适的单元测试框架测试编译后的源代码。这些测试不需要打包或部署代码 package - 将编译后的代码以其可分发的格式打包，例如JAR verify - 对集成测试的结果进行检查，以确保满足质量标准 install -将包安装到本地存储库中，作为本地其他项目中的依赖项使用 deploy - 在集成或发布环境中操作，将最终包复制到远程存储库，以便与其他开发人员和项目共享 这些生命周期阶段(加上这里没有显示的其他生命周期阶段)按顺序执行，以完成default生命周期。 鉴于上面的生命周期阶段，这意味着当使用default生命周期时。 Maven将首先验证项目，然后将视图编译源代码， 运行测试，打包二进制文件(如jar)， 运行集成测试方案，验证集成测试， 安装验证过的包到本地存储库，然后将安装包部署到远程存储库。 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:2:0","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["java知识"],"content":"插件(plugin)的目标(goal) Maven的操作是基于不同的插件的不同目标来实现的 例 mvn clean 使用的参数是clean阶段，而实际执行的是maven-clean-plugin插件的clean目标。 常用的插件 插件 maven-clean-plugin maven-resouces-plugin maven-compiler-plugin maven-deploy-plugin maven-surefire-plugin maven-install-plugin 直接运行插件 可使用插件名:目标名的参数形式直接运行某插件的某目标。 例如： mvn dependency:copy-dependencies 以上命令执行了dependency插件的copy-dependencies目标。 阶段(phase)和插件目标(goal)可以同时使用 例如： mvn clean dependency:copy-dependencies package 执行了clean周期的pre-clean和clean阶段， dependency插件的copy-dependencies目标， default周期package阶段及package之前的所有阶段。 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:3:0","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["java知识"],"content":"绑定的整个工作原理 官方文档 groupId：组织标识名（简单理解成 包名） artifactId：项目名称 version：项目的当前版本 packaging：项目的打包方式，最为常见的jar和war两种（项目中继承的话，为pom） classifier: 该元素用来帮助定义构建输出的一些附属构件（不能被直接定义） 依赖性管理，在pom.xml文件中\u003cdependency\u003e\u003c/dependency\u003e中 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:0","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["java知识"],"content":"依赖传递 若A依赖B，B依赖C，则A也依赖于C（A对于C为间接依赖） ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:1","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["java知识"],"content":"仓库管理 仓库用来统一存储所有Maven共享构建的位置， 根据maven坐标，目录方式：groupId/artifactId/version/artifactId-version.packaging 就可以唯一确定一个构建。 每个用户只有一个本地仓库，默认是在${user.home}/.m2/repository/，${user.home}代表的是用户目录 Maven默认的远程仓库：URL：http://search.maven.org/，我们需要引用外部的包时，可以从上面查到相关的GroupId、版本号等信息 私服：是一种特殊的远程仓库，架设在局域网内的仓库（一般公司内部都会有一个自己的私服） ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:2","tags":["java"],"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["各种问题"],"content":"题目地址 ","date":"2021-11-09","objectID":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:0","tags":["问题"],"title":"Docker挂载问题解决","uri":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["各种问题"],"content":"docker desktop win10挂载问题解决 系统：win10 docker pull blindpirate/hcsp-quiz 尝试自己编写一个docker run命令，完成以下要求： 使用交互式命令行模式(-it)启动Docker容器。 向启动的Docker容器内挂载一个文件（卷），使得容器内能够读取到/app/config.txt文件，其内容为字符串\"ABC\"。 向启动的Docker容器内传递一个环境变量HCSP_ENV=DEF。 为启动的Docker容器设置要执行的命令：java Main。 如果一切正确，命令行会输出： 答案是: XXXXX The answer is: XXXXXXX 提示未winpty docker run -e HCSP_ENV=DEF -itv //e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz 未挂载 winpty docker run -e HCSP_ENV=DEF -itv /e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz 成功 winpty docker run -e HCSP_ENV=DEF -itv //e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz ","date":"2021-11-09","objectID":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":["问题"],"title":"Docker挂载问题解决","uri":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["各种问题"],"content":"idea版本2021.2.1 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:0","tags":["问题"],"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["各种问题"],"content":"连接mysql报错 删除这三个就测试成功 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":["问题"],"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["各种问题"],"content":"例： docker run --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:5.7.27 docker run --name=mediawiki_mysql \\ -e MYSQL_DATABASE=wikidb \\ -e MYSQL_USER=wikiuser \\ -e MYSQL_PASSWORD=mysecret \\ -e MYSQL_ROOT_PASSWORD=zhang123 \\ -v /var/mediawiki/mysql:/var/lib/mysql \\ -d mysql:5.7.27 上面命令中的 \\ 是换行 -d 是指定镜像，本地没有的话会从docker服务器下载 -p 映射容器的3306到本地3306，前面是本地端口，-p 3306:3306 这里已经设置了一组管理数据库的用户名:wikiuser 密码:mysecret 通常使用-e MYSQL_RANDOM_ROOT_PASSWORD=1 把root设置为随机，只使用wikiuser用户来管理 -v 是映射本地目录到容器，目录需要提前创建，或者sudo chmod 777 /var/mediawiki，启动容器会自己创建mysql目录 进入容器： docker exec -it [容器名或容器ID] bash ","date":"2021-11-02","objectID":"https://hahaen.github.io/docker-run-mysql%E6%98%A0%E5%B0%84/:0:0","tags":["问题"],"title":"Docker Run Mysql映射","uri":"https://hahaen.github.io/docker-run-mysql%E6%98%A0%E5%B0%84/"},{"categories":["java知识"],"content":"正则表达式在线测试 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"基本用法 常用的元字符 ^ 开始位置 $ 结束位置 . 单个任意字符（不⼀一定包含换⾏行行符 \\w 单个“word”字符字母/数字/下划线/汉字 \\s 单个空白字符（\\n\\r\\t） \\d 单个数字字符 \\b 单词的开始或结束 重复 * 0次或多次 + 1次或多次 ？ 0次或1次 {n} n次 {n,} \u003e=n次 {n,m} n到m次 选择 [aeiou] 单个的a/e/i/o/u字符之⼀一 [0-9] 单个数字字符 [A-Z] 单个大写字母 [A-Z0-9] 大写字母或者数字或者下划线 Hi|hi 等价于 [Hh]i Hi或者hi 反义 [^aeiou] 单个的除a/e/i/o/u之外的字符 [^A] 单个非x字符 \\W 单个非\\w（字⺟母/数字/下划线/汉字） \\S 单个非\\s（空白) \\D 单个非\\d（数字）字符 \\B 非开头/结束位置 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中的正则表达式 String split() replaceAll/replaceFirst matches 效率低 尽量少用、少编译 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"分组与捕获 左括号( –开始数 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中处理捕获 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":["java"],"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["html"],"content":"URL 英文：Uniform Resource Locator https://zh.wikipedia.org:443/w/index.php?title=随机页面 https，是协议； zh.wikipedia.org，是服务器； 443，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:随机页面，是询问。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:1:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"DNS 英文：Domain Name System ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"作用： 根据域名查出IP地址 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:1","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"nslookup 命令 用于互动式地查询域名记录 进入交互模式，总共有两种方法。 第一种方法，直接输入 nslookup 命令，不加任何参数，则直接进入交互模式，此时 nslookup 会连接到默认的域名服务器（即 /etc/resolv.conf 的第一个 dns 地址）。 第二种方法，是支持选定不同域名服务器的。需要设置第一个参数为“-”，然后第二个参数是设置要连接的域名服务器主机名或 IP 地址。 如果你直接在 nslookup 命令后加上所要查询的 IP 或主机名，那么就进入了非交互模式。当然，也可以在第二个参数位置设置所要连接的域名服务器。 例子 交互模式下查询域名 nslookup \u003e www.douban.com Server: 127.0.1.1 // 往上连接的 DNS 服务器 Address: 127.0.1.1#53 // DNS 服务器 IP 地址与端口 Non-authoritative answer: // 非权威答案，从上连 DNS 服务器本地缓存中读取，非实际查询得到 Name: www.douban.com Address: 115.182.201.6 // IP 地址 Name: www.douban.com Address: 115.182.201.7 Name: www.douban.com Address: 115.182.201.8 交互模式下更改 DNS 进入交互模式之后，使用 server dns-server 来改变上连 DNS 服务器地址 查询域名 ip 地址 nslookup www.douban.com [dns-server] //如果没有指定 dns-server，使用系统默认的 DNS 服务器。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:2","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"IP ip138-查询本机ip ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"IP地址： 互联网协议地址 IP地址是人们在Internet上为了区分数以亿计的主机而给每台主机分配的一个专门的地址，通过IP地址就可以访问到每一台主机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:1","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"ping 命令 Ping 命令详解 输入ping /? ，列出ping的相关参数 用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name -t ：Ping 指定的计算机直到中断。 -a ：将地址解析为计算机名。 -n count ：发送 count 指定的 ECHO 数据包数。默认值为 4。 -l size ：发送包含由 size 指定的数据量的 ECHO 数据包。默认为 32 字节；最大值是65,527。 -f ：在数据包中发送\"不要分段\"标志。数据包就不会被路由上的网关分段。 -i ttl :将\"生存时间\"字段设置为 ttl 指定的值。 -v tos :将\"服务类型\"字段设置为 tos 指定的值。 -r count :在\"记录路由\"字段中记录传出和返回数据包的路由。count 可以指定最少 1 台，最多 9 台计算机。 -s count :指定 count 指定的跃点数的时间戳。 -j host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机可以被中间网关分隔（路由稀疏源）IP 允许的最大数量为 9。 -k host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机不能被中间网关分隔（路由严格源）IP 允许的最大数量为 9。 -w timeout :指定超时间隔，单位为毫秒。 destination-list :指定要 ping 的远程计算机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:2","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"域名 域名-维基百科 域名是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。 www.xiedaimala.com和xiedaimala.com 不是同一域名 com是顶级域名 xiedaimala.com是二级域名(俗称一级域名) www.xiedaimala.com是三级域名(俗称二级) 上面的两是父子关系 例如 github. io把子域名 XXX.github.io免费给你使用 所以www.xiedaimala.com和xiedaimala. com可以不是同一家公司,也可以是 www是多余的,非常多余。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:4:0","tags":["HTML"],"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["html"],"content":"搜索技巧： 谷歌搜索 mdn + xx(标签) ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"a 标签的用法 ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"href \u003cul\u003e \u003cli\u003e\u003ca href=\"http://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"https://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"//baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/a/b/index.html\"\u003e/a/b/index.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"./index.html\"\u003eindex.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789@163.com\"\u003eEmail\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789\"\u003ePhone\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e 注意: 可以使用 href=\"#top\" 或者 href=\"#\" 链接返回到页面顶部。 ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:1","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"target _self: 当前页面加载。此值是默认的，如果没有指定属性的话。 _blank: 新窗口打开。 _parent: 加载响应到当前的浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式与 _self 相同。 _top: IHTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:2","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 a ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:3","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"img 标签的用法 \u003cimg class=\"fit-picture\" src=\"1.jpg\" alt=\"网络错误\"\u003e src 属性是必须的，它包含了你想嵌入的图片的文件路径。 alt 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。 img ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"table 标签的用法 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eThe table header\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eThe table body\u003c/td\u003e \u003ctd\u003ewith two columns\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e table ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":["HTML"],"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["java知识"],"content":"Java多线程原理 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"为什么需要多线程？ 可以提高程序的执行性能 例如：一个人洗菜做法，和多个人一起洗菜做饭效率不一样。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"多线程带来了什么问题，如何避免？ 线程安全问题 例如：银行存钱取件需要完整，不可出现错误。 保证线程安全需要满足两大条件： 原子性：一系列操作，要么全部完成，要么全部不完成，不可被分割，不会结束在中间某个环节。 可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 上下文切换 线程与 CPU 单核执行是一对一的 CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行，在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态 线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用 这就是当我们开启大量线程，系统反而更慢 解决办法 减少锁等待 使用合适的线程数 CAS 算法 死锁 线程 A 和线程 B 都拥有一份锁，而线程 A 和线程 B 恰好同时去获取对方拥有的那把锁， 导致两个线程永远无法执行， 要避免死锁有一个方法即获取锁的顺序是固定的， 比如只能先获取锁 X 再获取锁 Y，不允许出现相反的顺序。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"线程的属性、状态、生命周期详解 线程可以分为5个状态： New(新建) Runnable（就绪） Running(运行) blocked(被阻塞) Dead(死亡) New(新建) 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 Thread t1=new Thread(); Runnable（就绪） 线程已经被启动，正在等待被分配给CPU时间片， 也就是说此时线程正在就绪队列中排队等候得到CPU资源。 t1.start(); Running(运行) 线程获得CPU资源正在执行任务（run()方法）， 此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入， 线程将一直运行到结束。 blocked(被阻塞) 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） Dead(死亡) 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:3","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"什么是ThreadLocal？ 每个线程自己独有的，不与其它线程共享的变量。 常用的两内部类，四个方法： get()方法是用来获取ThreadLocal在当前线程中保存的变量副本。 set()用来设置当前线程中变量的副本。 remove()用来移除当前线程中变量的副本。 initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:4","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"为什么需要线程池？ 线程池 在Java 5之后，Java通过Executor来启动线程，比使用Thread的start方法更好， 除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题。 简单的说就是把线程统一管理。 线程池优势： 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行； 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。 提供更强大的功能，延时定时线程池。 Java的4种默认线程池 newSingleThreadExecutor 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixeThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:5","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"线程池的构造函数中的参数都是什么含义？ ThreadPollExecutor中的所有的构造函数最终都会调用上面这个构造函数，接下来我们来分析一下这些参数的含义： corePoolSize： 线程池启动后，在池中保持的线程的最小数量。 需要说明的是线程数量是逐步到达corePoolSize值的。 例如corePoolSize被设置为10，而任务数量只有5，则线程池中最多会启动5个线程，而不是一次性地启动10个线程。 maxinumPoolSize： 线程池中能容纳的最大线程数量， 如果超出，则使用RejectedExecutionHandler拒绝策略处理。 keepAliveTime： 线程的最大生命周期。这里的生命周期有两个约束条件： 一：该参数针对的是超过corePoolSize数量的线程； 二：处于非运行状态的线程。 例：如果corePoolSize（最小线程数）为10，maxinumPoolSize（最大线程数）为20，而此时线程池中有15个线程在运行，过了一段时间后，其中有3个线程处于等待状态的时间超过keepAliveTime指定的时间，则结束这3个线程，此时线程池中则还有12个线程正在运行。 unit： 这是keepAliveTime的时间单位 可以是纳秒，毫秒，秒，分钟等。 workQueue： 任务队列。 当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。 这个任务队列是一个阻塞式的单端队列。 newFixedThreadPool和newSingleThreadExector使用的是LinkedBlockingQueue的无界模式。 threadFactory： 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。 handler： 拒绝任务处理器。 由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。 线程的管理过程： 首先创建一个线程池， 然后根据任务的数量逐步将线程增大到corePoolSize， 如果此时仍有任务增加，则放置到workQueue中，直到workQueue爆满为止， 然后继续增加池中的线程数量（增强处理能力），最终达到maxinumPoolSize。 那如果此时还有任务要增加进来，需要handler来处理， 或者丢弃新任务，或者拒绝新任务，或者挤占已有的任务。 在任务队列和线程池都饱和的情况下，一旦有线程处于等待（任务处理完毕，没有新任务）状态的时间超过keepAliveTime，则该线程终止， 也就是说池中的线程数量会逐渐降低，直至为corePoolSize数量为止。 总结 corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程 maximumPoolSize: 线程池维护线程的最大线程数 keepAliveTime: 线程池维护线程所允许的空闲时间 unit: 程池维护线程所允许的空闲时间的单位 workQueue: 线程池所使用的缓冲队列 handler: 线程池对拒绝任务的处理策略 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:6","tags":["java"],"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Http方法与状态码 http方法 GET 拿 POST 发送 GET / HTTP/1.1 //GET请求根路径 使用HTTP1.1协议 Host: xiedaimala.com User-Agent: //用户代理（浏览器） 可根据查看相关信息 Http状态码 200请求成功。一般用于GET与POST请求 http猫 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:1:0","tags":["java"],"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["java知识"],"content":"HTTP的header与body 重要的header Accept Cookie User-Agent //浏览器标识 Referer //上一个页面是什么 Referer: http://idpeng.xyz/ Content-type //下载或者图片 content-type: text/html; charset=utf-8 Set-Cookie //登录后服务器自动设置的cookie http是无状态的 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:2:0","tags":["java"],"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["java知识"],"content":"计算机网络是如何工作的 在打开网页的时候发生了什么 主机 域名与DNS 端⼝:HTTPS协议的默认端⼝口是443，HTTP协议的默认端⼝口是80 TCP协议 HTTP协议 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:1:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"浏览器是如何工作的 在网络上传输的只是字节流 HTTP协议 HTML JavaScript CSS ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:2:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"同步与异步加载 同步加载：同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 异步加载：异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。 服务器端一次返回所有的数据 服务器端返回部分数据，使用AJAX异步加载 区别 异步：在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。 同步：在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:3:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"注意 只要浏览器能做到的 其他代码一定能做到 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:4:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"Collection体系的常用类及其背后的数据结构 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection常用类 list 有序可重复，拥有下标,最常用的是 ArrayList，实际就是一个数组 常用类： ArrayList LinkedList set 无序且不可重复的元素集合,没有下标。 HashSet（无序） LinkedHashSet（有序） TreeSet（排序） Collection体系简介图 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection背后的数据结构 ArrayList与LinedList Arraylist：底层使用的是Object 数组。 LinkedList：底层使用的是 双向链表 数据结构。 HashSet、LinkedHashSet与TreeSet HashSet: 底层采用 HashMap 来保存元素，HashMap 使用的是拉链法，也叫作链地址法。 LinkedHashSet：底层是链表+哈希表，链表保证数据存储有序，链表用来记录存储顺序；哈希表保证数据唯一，存储真正的数据 TreeSet：红黑树 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList源码阅读 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"继承结构 ArrayList extends AbstractList AbstractList extends AbstractCollection ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"构造方法 ArrayList有三个构造方法 无参构造方法 /** * Constructs an empty list with an initial capacity of ten.　默认会给10的大小，所以说一开始arrayList的容量是10. */ //ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData; 　public ArrayList() {　super(); //调用父类中的无参构造方法，父类中的是个空的构造方法 this.elementData = EMPTY_ELEMENTDATA; //EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。 } 有参构造方法 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) { super(); //父类中空的构造方法 if (initialCapacity \u003c 0) //判断如果自定义大小的容量小于0，则报下面这个非法数据异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; //将自定义的容量大小当成初始化elementData的大小 } 有参构造方法(不常用) //这个构造方法不常用，举个例子就能明白什么意思 /* Strudent exends Person ArrayList\u003cPerson\u003e、 Person这里就是泛型 我还有一个Collection\u003cStudent\u003e、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection\u003cStudent\u003e转换为ArrayList\u003cSudent\u003e这就是这个构造方法的作用 */ public ArrayList(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); //转换为数组 size = elementData.length; //数组中的数据个数 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。 elementData = Arrays.copyOf(elementData, size, Object[].class); }　 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"add()方法 add(E) //默认直接在末尾添加元素 add(int，E)//在特定位置添加元素，也就是插入元素 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:3","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"remove()方法 remove(int)//通过删除指定位置上的元素 remove(Object)//这个方法可以看出来，arrayList是可以存放null值得。 clear()//将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:4","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"set()方法 设定指定下标索引的元素值 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:5","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"indexOf()方法 从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:6","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get()方法 get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0） ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:7","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList是如何扩容的？ 扩容操作 /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 新容量扩大到原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) // 如果新容量还是比所需的最小容量小，则让新容量等于所需的最小容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) // 如果新容量超过了Integer.MAX_VALUE - 8，继续计算 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 所需的最小容量minCapacity 接近size elementData = Arrays.copyOf(elementData, newCapacity); } 扩容计算，int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); oldCapacity 是ArrayList 内部数组长度，oldCapacity » 1 是位运算的右移操作，右移一位相当于除以2，新的容量 newCapacity 为之前容量的1.5倍。 elementData = Arrays.copyOf(elementData, newCapacity); 对 elementData 数组进行扩容。 private static int hugeCapacity(int minCapacity) { if (minCapacity \u003c 0) // overflow throw new OutOfMemoryError(); return (minCapacity \u003e MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } ArrayList 扩容每次都是原容量的1.5倍吗？ 从源码中可以看出，当使用无参构造方法创建一个 ArrayList 实例，调用 add 方法添加第一个元素的时候，calculateCapacity 方法返回的是默认初始容量 DEFAULT_CAPACITY 大小为10；当使用指定初始容量创建ArrayList 实例，调用 addAll 方法添加多个元素的时候，原容量的1.5倍也无法存放元素的时候，会创建一个更大（不会超过 Integer.MAX_VALUE）的数组来存放元素。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:3:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap源码阅读 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } //第四个参数是，只有当key对应的位置为空的时候，才进行替换，一般设置为false //第五个参数如果是false，表示是在第一次放置+初始化数组容量的时候调用。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; //如果table数组为空，则进行第一次resize,扩容到初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果key在数组中映射的位置上的元素为空，没有产生哈希冲突，则直接放置 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; //如果key值相同，则直接覆盖 if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; //如果key值不同，则产生了哈希冲突，需要解决冲突 else if (p instanceof TreeNode)//如果当前是个树节点，则需要往树上放置元素 e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { //是个链表 for (int binCount = 0; ; ++binCount) { //如果走到链表的末尾，则直接新建一个节点，插入到链表末尾 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //判断需不需要进行变形，把链表变成红黑树，提高查找效率 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果当前的key值和链表上的某个key值相同 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; //指针移动 p = e; } } //如果循环结束后，e不等于null，则e的value值需要被替换成新的value值 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //HashMap的这个函数是空的，LinkedHashMap继承HashMap重写了这个方法，用来实现插入有序，或者LRU访问 afterNodeAccess(e); return oldValue; } } //修改数++ ++modCount; //如果当前数组的容量超过了扩容的阈值，则进行扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get方法 //根据key值获取 public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u003cK,V\u003e getNode(int hash, Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k; //table数组不为空,且length\u003e0，且hash值和数组长度做\u0026运算得到的那个bucket不为空 if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { //如果是第一个节点，则直接返回第一个节点 if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; //开始找下一个节点 if ((e = first.next) != null) { //如果下一个节点是红黑树节点 if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); //则开始在树上找节点 do { //如果是链表节点，一直遍历链表，知道找到。 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } //否则直接返回空 return null; } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap是如何扩容的？ HashMap 中的 resize 方法主要包含两部分逻辑： 初始化数组 table，并设置阈值。 数组容量翻倍，将元素迁移到新数组。 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u003e 0) { // 第一次进来，table为null，oldCap为0，不会进入这里 if (oldCap \u003e= MAXIMUM_CAPACITY) { // 扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; // 取整型最大值(2^31-1)，这样以后就不会扩容了 return oldTab; } else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 // oldCap翻倍得到newCap oldCap \u003e= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u003c\u003c 1; // double threshold } else if (oldThr \u003e 0) // initial capacity was placed in threshold // 第一次进来，如果手动设置了初始容量initialCapacity，这里为true，则将threshold作为初始容量 newCap = oldThr; else { // zero initial threshold signifies using defaults // 如果没有手动设置initialCapacity，则设为默认值16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { // 第一次进来，这里必为true，重新计算 threshold = capacity * Load factor float ft = (float)newCap * loadFactor; newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; table = newTab; if (oldTab != null) { // 对oldTab中所有元素进行rehash。由于每次扩容是2次幂的扩展(指数组长度/桶数量扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置 for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { // 数组j位置的元素不为空，需要该位置上的所有元素进行rehash oldTab[j] = null; if (e.next == null) // 桶中只有一个元素，则直接rehash newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) // 桶中是树结构 ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order // 桶中是链表结构（JDK1.7中旧链表迁移新链表的时候，用的是头插法，如果在新表的数组索引位置相同，则链表元素会倒置；但是JDK1.8不会倒置，用的是双指针） Node\u003cK,V\u003e loHead = null, loTail = null; // low位链表，其桶位置不变，head和tail分别代表首尾指针 Node\u003cK,V\u003e hiHead = null, hiTail = null; // high位链表，其桶位于追加后的新数组中 Node\u003cK,V\u003e next; do { next = e.next; if ((e.hash \u0026 oldCap) == 0) { // 是0的话索引没变，是1的话索引变成“原索引+oldCap” if (loTail == null) loHead = e; // 总是指向头结点 else loTail.next = e; // 该操作有可能会改变原链表结构 loTail = e; // 总是指向下一个节点，直到尾节点 } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; // 原索引 } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; // 原索引+oldCap } } } } } return newTab; } HashMap 每次扩容都是建立一个新的 table 数组，长度和容量阈值都变为原来的两倍，然后把原数组元素重新映射到新数组上，具体步骤如下： 首先会判断 table 数组长度，如果大于 0 说明已被初始化过，那么按当前 table 数组长度的 2 倍进行扩容，阈值也变为原来的 2 倍 若 table 数组未被初始化过，且 threshold(阈值)大于 0 说明调用了 HashMap(initialCapacity, loadFactor) 构造方法，那么就把数组大小设为 threshold 若 table 数组未被初始化，且 threshold 为 0 说明调用 HashMap() 构造方法，那么就把数组大小设为 16，threshold 设为 16*0.75 接着需要判断如果不是第一次初始化，那么扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去，如果节点是红黑树类型的话则需要进行红黑树的拆分 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:5:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap从Java7到Java8发生了哪些变化？ JDK 7 是先对 size++ 进行检查， 如果超过阈值， 则扩容，最后把节点放入 table。 而 JDK 8 相反，先把节点放入， 放入后的 size 若超出， 则扩容 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:6:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"为什么HashMap不是线程安全的？ JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。 JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:7:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection体系简介 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"list Collection\u003cInteger\u003e c = new LinkedHashSet\u003c\u003e(); // IntegerList List\u003cInteger\u003e list = new ArrayList\u003c\u003e(c); // 等价于 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(); list2.addAll(c); // 等价于 List\u003cInteger\u003e list3 = new ArrayList\u003c\u003e(); for (Integer i : c) { list3.add(i); } ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Set 只是简单通过object.contains()判断添加新元素时是否重复，从而实现去重的 Set 是很低效的，这就引出了对象的 hashcode。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Java世界第⼆重要的约定 hashCode: 同⼀个对象必须始终返回相同的 hashCode 两个对象的 equals 返回 true，必须返回相同的 hashCode 两个对象不等，也可能返回相同的 hashCode ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:3","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashSet HashSet 是无序的，是最常用的 Set 实现。 可以利用 set 为 list 过滤去重： List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(2); list.add(3); list.add(4); list.add(3); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(list); LinkedHashSet 是有序的，顺序就是插入元素时的顺序。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:4","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collections ⼯具⽅法集合 emptySet(): 等返回⼀一个⽅方便便的空集合 synchronizedCollection: 将⼀一个集合变成线程安全的 unmodifiableCollection: 将⼀一个集合变成不不可变的（也可以使⽤用Guava的Immutable） ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:5","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Map 体系 map 是 一个将 keys 映射到 values 的对象，键不能重复，每个键只能映射一个值，值可以重复。 keySet()返回键的集合，因为键不可重复，所以可以返回一个 set； values()返回值的集合，因为值可以重复，所以返回的是 collection。 注意：keySet()和 map背后的 keys 是同一组数据，所以二者的修改会相互影响。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap HashMap 是最常用、最高效的 Map 实现。 HashMap 的扩容，思路同样是创建更大的空间，然后把之前的数据 copy 进来。 HashMap 是多线程不安全的，可使用 ConcurrentHashMap。 Java 7 开始会采用代替链表 HashMap 和 HashSet 本质上是同一个东西： HashMap 的 key 集合（set）就是 HashSet，而 HashSet 内部其实就是个 HashMap，毕竟 HashSet 拥有的功能 HashMap 都有。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:1","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"有序集合TreeSet/TreeMap TreeSet 可以排序（默认是自然顺序）。 HashSet、LinkedHashSet 与 TreeSet 对比： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = Arrays.asList(1000, -13, 0, -41656, 1250, 555); Set set1 = new HashSet\u003c\u003e(list); Set set2= new LinkedHashSet(list); Set set3 = new TreeSet(list); System.out.println(set1); System.out.println(set2); System.out.println(set3); } } [0, 1250, -41656, 1000, 555, -13] [1000, -13, 0, -41656, 1250, 555] [-41656, -13, 0, 555, 1000, 1250] TreeMap 同理 ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:2","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Guava 不要重复发明轮⼦子！尽量量使⽤用经过实战检验的类库 Lists/Sets/Maps ImmutableMap/ImmutableSet Multiset/Multimap BiMap ","date":"2021-09-11","objectID":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:10:0","tags":["java"],"title":"Collection体系原理","uri":"https://hahaen.github.io/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"jar jar是将很多类文件打包后的一个压缩包,导入 jar 后,可以直接使用里面的类或调用其中的功能。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:1:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"java包的原理 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"传递性依赖 我们依赖的包还依赖了别的类，这种依赖是具有传递性的。 传递性依赖带来的最大的问题就是： 我们在 -classpath 后会添加项目依赖的各种各样的 jar 包； 如果两个仅仅不同版本的 jar 包被同时写进了 -classpath 参数里面； JVM 在 classpath 中寻找类文件的顺序是从前找到后的，也就是说如果有两个仅仅不同版本的 jar ：demo-1.0.jar 和 demo-2.0.jar ，哪个放在前面哪个就会被使用。 如果 demo-1.0.jar 的顺序在 demo-2.0.jar 之前，就会使用demo-1.0.jar加载的类文件，这样的话高版本的jar就会不生效。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven包的管理 Maven 是一个项目管理工具它包含： 一个项目对象模型 一组标准集合 一个项目生命周期 一个依赖管理系统 用来运行定义在生命周期阶段中插件目标的逻辑 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven怎么进行管理 Maven 包管理的做法是：Convention over configuration（约定优于配置原则），体现在 POM。 POM是 Maven 工程的基本工作单元，是一个 XML 文件。 该文件中包含了项目的基本信息，用于描述项目如何构建，声明项目依赖等等。 pom.xml \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ehcsp\u003c/groupId\u003e \u003cartifactId\u003efix-bug-in-integer-equals\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003ealiyunMavenMirror\u003c/id\u003e \u003cactivation\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003c/profiles\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.1\u003c/version\u003e \u003cconfiguration\u003e \u003cargLine\u003e-Dfile.encoding=UTF-8\u003c/argLine\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 引入第三方包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 里面加入了junit-jupiter-engine的jar 如果在本地仓库没有找到对应的 jar 包，Maven 就会从远程的中央仓库进行下载，然后放到本地仓库中。 Maven 中央仓库位置 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突及解决办法 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:0","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突 相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:1","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"解决冲突的办法 直接依赖C2 排除C1 通过Maven helper插件来解决包冲突问题 排除 \u003cdependency\u003e \u003cgroupId\u003exxx\u003c/groupId\u003e \u003cartifactId\u003exxx\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eyyy\u003c/groupId\u003e \u003cartifactId\u003eyyy\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 排除了xxx依赖中的后代yyy依赖，也可以解决包冲突的问题 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:2","tags":["java"],"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"git系列操作 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:0:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"git六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor \"code --wait\" git config --global core.autocrlf input 注意： 上面的英文名和邮箱跟 GitHub 没有关系。 可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:1:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"新建代码库 # 在当前目录新建一个 Git 代码库 git init # 新建一个目录，将其初始化为 Git 代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:2:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"配置文件 # 显示当前的 Git 配置 git config --list # 编辑 Git 配置文件 git config -e [--global] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:3:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区 git commit -m [message] # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] # 提交工作区自上次 commit 之后的变化，直接到仓库区 git commit -a # 提交时显示所有 diff 信息(推荐) git commit -v # 使用一次新的 commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 git commit --amend -m [message] # 重做上一次 commit，并包括指定文件的新变化 git commit --amend ... ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:4:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定 commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个 commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete git branch -dr ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:5:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"提交代码 git pull 提交代码到远程仓库 git push -u origin master 提交本地指定分支master代码到远程仓库 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:6:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"ls命令 list 的缩写,可以查看文件权限(包括目录、文件夹、文件权限),查看目录信息。 ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cd命令 cd [目录名] 进入目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"pwd命令 pwd 查看当前路径 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mkdik命令 mkdir t 在当前工作目录下创建名为 t的文件夹 mkdir -p /tmp/test/t1/t 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"rm命令 rm -i *.log 删除任何 .log 文件，删除前逐一询问确认 rm -rf test 删除 test 子目录及子目录中所有档案删除，并且不用一一确认 rm -- -f* 删除以 -f 开头的文件 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mv命令 mv test.log test1.txt 将文件 test.log 重命名为 test1.txt mv llog1.txt log2.txt log3.txt /test3 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv -i log1.txt log2.txt 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv * ../ 移动当前文件夹下的所有文件到上一级目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cp命令 -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cat命令 cat filename 一次显示整个文件 cat \u003e filename 从键盘创建一个文件 cat file1 file2 \u003e file 将几个文件合并为一个文件 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:1","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"常用操作命令 Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:2","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"which 命令 which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":["java"],"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]