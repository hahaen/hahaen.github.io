[{"categories":["爬虫项目实战"],"content":"Java多线程原理 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"为什么需要多线程？ 可以提高程序的执行性能 例如：一个人洗菜做法，和多个人一起洗菜做饭效率不一样。 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"多线程带来了什么问题，如何避免？ 线程安全问题 例如：银行存钱取件需要完整，不可出现错误。 保证线程安全需要满足两大条件： 原子性：一系列操作，要么全部完成，要么全部不完成，不可被分割，不会结束在中间某个环节。 可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 上下文切换 线程与 CPU 单核执行是一对一的 CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行，在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态 线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用 这就是当我们开启大量线程，系统反而更慢 解决办法 减少锁等待 使用合适的线程数 CAS 算法 死锁 线程 A 和线程 B 都拥有一份锁，而线程 A 和线程 B 恰好同时去获取对方拥有的那把锁， 导致两个线程永远无法执行， 要避免死锁有一个方法即获取锁的顺序是固定的， 比如只能先获取锁 X 再获取锁 Y，不允许出现相反的顺序。 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"线程的属性、状态、生命周期详解 线程可以分为5个状态： New(新建) Runnable（就绪） Running(运行) blocked(被阻塞) Dead(死亡) New(新建) 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 Thread t1=new Thread(); Runnable（就绪） 线程已经被启动，正在等待被分配给CPU时间片， 也就是说此时线程正在就绪队列中排队等候得到CPU资源。 t1.start(); Running(运行) 线程获得CPU资源正在执行任务（run()方法）， 此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入， 线程将一直运行到结束。 blocked(被阻塞) 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。 正在等待：调用wait()方法。（调用motify()方法回到就绪状态） 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复） Dead(死亡) 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。 自然终止：正常运行run()方法后终止 异常终止：调用stop()方法让一个线程终止运行 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:3","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"什么是ThreadLocal？ 每个线程自己独有的，不与其它线程共享的变量。 常用的两内部类，四个方法： get()方法是用来获取ThreadLocal在当前线程中保存的变量副本。 set()用来设置当前线程中变量的副本。 remove()用来移除当前线程中变量的副本。 initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:4","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"为什么需要线程池？ 线程池 在Java 5之后，Java通过Executor来启动线程，比使用Thread的start方法更好， 除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题。 简单的说就是把线程统一管理。 线程池优势： 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行； 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。 提供更强大的功能，延时定时线程池。 Java的4种默认线程池 newSingleThreadExecutor 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixeThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:5","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"线程池的构造函数中的参数都是什么含义？ ThreadPollExecutor中的所有的构造函数最终都会调用上面这个构造函数，接下来我们来分析一下这些参数的含义： corePoolSize： 线程池启动后，在池中保持的线程的最小数量。 需要说明的是线程数量是逐步到达corePoolSize值的。 例如corePoolSize被设置为10，而任务数量只有5，则线程池中最多会启动5个线程，而不是一次性地启动10个线程。 maxinumPoolSize： 线程池中能容纳的最大线程数量， 如果超出，则使用RejectedExecutionHandler拒绝策略处理。 keepAliveTime： 线程的最大生命周期。这里的生命周期有两个约束条件： 一：该参数针对的是超过corePoolSize数量的线程； 二：处于非运行状态的线程。 例：如果corePoolSize（最小线程数）为10，maxinumPoolSize（最大线程数）为20，而此时线程池中有15个线程在运行，过了一段时间后，其中有3个线程处于等待状态的时间超过keepAliveTime指定的时间，则结束这3个线程，此时线程池中则还有12个线程正在运行。 unit： 这是keepAliveTime的时间单位 可以是纳秒，毫秒，秒，分钟等。 workQueue： 任务队列。 当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。 这个任务队列是一个阻塞式的单端队列。 newFixedThreadPool和newSingleThreadExector使用的是LinkedBlockingQueue的无界模式。 threadFactory： 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。 handler： 拒绝任务处理器。 由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。 线程的管理过程： 首先创建一个线程池， 然后根据任务的数量逐步将线程增大到corePoolSize， 如果此时仍有任务增加，则放置到workQueue中，直到workQueue爆满为止， 然后继续增加池中的线程数量（增强处理能力），最终达到maxinumPoolSize。 那如果此时还有任务要增加进来，需要handler来处理， 或者丢弃新任务，或者拒绝新任务，或者挤占已有的任务。 在任务队列和线程池都饱和的情况下，一旦有线程处于等待（任务处理完毕，没有新任务）状态的时间超过keepAliveTime，则该线程终止， 也就是说池中的线程数量会逐渐降低，直至为corePoolSize数量为止。 总结 corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程 maximumPoolSize: 线程池维护线程的最大线程数 keepAliveTime: 线程池维护线程所允许的空闲时间 unit: 程池维护线程所允许的空闲时间的单位 workQueue: 线程池所使用的缓冲队列 handler: 线程池对拒绝任务的处理策略 ","date":"2021-09-28","objectID":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:6","tags":["java"],"title":"Java多线程原理","uri":"https://idpeng.xyz/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["爬虫项目实战"],"content":"内容 ","date":"2021-09-13","objectID":"https://idpeng.xyz/java%E7%9A%84io/:0:0","tags":["java"],"title":"Java的IO","uri":"https://idpeng.xyz/java%E7%9A%84io/"},{"categories":["爬虫项目实战"],"content":"Http方法与状态码 http方法 GET 拿 POST 发送 GET / HTTP/1.1 //GET请求根路径 使用HTTP1.1协议 Host: xiedaimala.com User-Agent: //用户代理（浏览器） 可根据查看相关信息 Http状态码 200请求成功。一般用于GET与POST请求 http猫 ","date":"2021-09-13","objectID":"https://idpeng.xyz/http%E7%9A%84%E5%9F%BA%E7%A1%80/:1:0","tags":["java"],"title":"HTTP的基础","uri":"https://idpeng.xyz/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["爬虫项目实战"],"content":"HTTP的header与body 重要的header Accept Cookie User-Agent //浏览器标识 Referer //上一个页面是什么 Referer: http://idpeng.xyz/ Content-type //下载或者图片 content-type: text/html; charset=utf-8 Set-Cookie //登录后服务器自动设置的cookie http是无状态的 ","date":"2021-09-13","objectID":"https://idpeng.xyz/http%E7%9A%84%E5%9F%BA%E7%A1%80/:2:0","tags":["java"],"title":"HTTP的基础","uri":"https://idpeng.xyz/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["爬虫项目实战"],"content":"计算机网络是如何工作的 在打开网页的时候发生了什么 主机 域名与DNS 端⼝:HTTPS协议的默认端⼝口是443，HTTP协议的默认端⼝口是80 TCP协议 HTTP协议 ","date":"2021-09-11","objectID":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:1:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"浏览器是如何工作的 在网络上传输的只是字节流 HTTP协议 HTML JavaScript CSS ","date":"2021-09-11","objectID":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:2:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"同步与异步加载 同步加载：同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 异步加载：异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。 服务器端一次返回所有的数据 服务器端返回部分数据，使用AJAX异步加载 区别 异步：在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。 同步：在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:3:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["爬虫项目实战"],"content":"注意 只要浏览器能做到的 其他代码一定能做到 ","date":"2021-09-11","objectID":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:4:0","tags":["java"],"title":"JavaWeb前后端架构分析","uri":"https://idpeng.xyz/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["java知识"],"content":"Collection体系的常用类及其背后的数据结构 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"C0llection常用类 list 有序可重复，拥有下标,最常用的是 ArrayList，实际就是一个数组 常用类： ArrayList LinkedList set 无序且不可重复的元素集合,没有下标。 HashSet（无序） LinkedHashSet（有序） TreeSet（排序） Collection体系简介图 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:1","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection背后的数据结构 ArrayList与LinedList Arraylist：底层使用的是Object 数组。 LinkedList：底层使用的是 双向链表 数据结构。 HashSet、LinkedHashSet与TreeSet HashSet: 底层采用 HashMap 来保存元素，HashMap 使用的是拉链法，也叫作链地址法。 LinkedHashSet：底层是链表+哈希表，链表保证数据存储有序，链表用来记录存储顺序；哈希表保证数据唯一，存储真正的数据 TreeSet：红黑树 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:1:2","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList源码阅读 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"继承结构 ArrayList extends AbstractList AbstractList extends AbstractCollection ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:1","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"构造方法 ArrayList有三个构造方法 无参构造方法 /** * Constructs an empty list with an initial capacity of ten.　默认会给10的大小，所以说一开始arrayList的容量是10. */ //ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData; 　public ArrayList() {　super(); //调用父类中的无参构造方法，父类中的是个空的构造方法 this.elementData = EMPTY_ELEMENTDATA; //EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。 } 有参构造方法 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) { super(); //父类中空的构造方法 if (initialCapacity \u003c 0) //判断如果自定义大小的容量小于0，则报下面这个非法数据异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; //将自定义的容量大小当成初始化elementData的大小 } 有参构造方法(不常用) //这个构造方法不常用，举个例子就能明白什么意思 /* Strudent exends Person ArrayList\u003cPerson\u003e、 Person这里就是泛型 我还有一个Collection\u003cStudent\u003e、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection\u003cStudent\u003e转换为ArrayList\u003cSudent\u003e这就是这个构造方法的作用 */ public ArrayList(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); //转换为数组 size = elementData.length; //数组中的数据个数 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。 elementData = Arrays.copyOf(elementData, size, Object[].class); }　 ###add()方法 add(E) //默认直接在末尾添加元素 add(int，E)//在特定位置添加元素，也就是插入元素 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:2","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"remove()方法 remove(int)//通过删除指定位置上的元素 remove(Object)//这个方法可以看出来，arrayList是可以存放null值得。 clear()//将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:3","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"set()方法 设定指定下标索引的元素值 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:4","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"indexOf()方法 从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:5","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get()方法 get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0） ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:2:6","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"ArrayList是如何扩容的？ 扩容操作 /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 新容量扩大到原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) // 如果新容量还是比所需的最小容量小，则让新容量等于所需的最小容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) // 如果新容量超过了Integer.MAX_VALUE - 8，继续计算 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 所需的最小容量minCapacity 接近size elementData = Arrays.copyOf(elementData, newCapacity); } 扩容计算，int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); oldCapacity 是ArrayList 内部数组长度，oldCapacity » 1 是位运算的右移操作，右移一位相当于除以2，新的容量 newCapacity 为之前容量的1.5倍。 elementData = Arrays.copyOf(elementData, newCapacity); 对 elementData 数组进行扩容。 private static int hugeCapacity(int minCapacity) { if (minCapacity \u003c 0) // overflow throw new OutOfMemoryError(); return (minCapacity \u003e MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } ArrayList 扩容每次都是原容量的1.5倍吗？ 从源码中可以看出，当使用无参构造方法创建一个 ArrayList 实例，调用 add 方法添加第一个元素的时候，calculateCapacity 方法返回的是默认初始容量 DEFAULT_CAPACITY 大小为10；当使用指定初始容量创建ArrayList 实例，调用 addAll 方法添加多个元素的时候，原容量的1.5倍也无法存放元素的时候，会创建一个更大（不会超过 Integer.MAX_VALUE）的数组来存放元素。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:3:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap源码阅读 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } //第四个参数是，只有当key对应的位置为空的时候，才进行替换，一般设置为false //第五个参数如果是false，表示是在第一次放置+初始化数组容量的时候调用。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; //如果table数组为空，则进行第一次resize,扩容到初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果key在数组中映射的位置上的元素为空，没有产生哈希冲突，则直接放置 if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; //如果key值相同，则直接覆盖 if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; //如果key值不同，则产生了哈希冲突，需要解决冲突 else if (p instanceof TreeNode)//如果当前是个树节点，则需要往树上放置元素 e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { //是个链表 for (int binCount = 0; ; ++binCount) { //如果走到链表的末尾，则直接新建一个节点，插入到链表末尾 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //判断需不需要进行变形，把链表变成红黑树，提高查找效率 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果当前的key值和链表上的某个key值相同 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; //指针移动 p = e; } } //如果循环结束后，e不等于null，则e的value值需要被替换成新的value值 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //HashMap的这个函数是空的，LinkedHashMap继承HashMap重写了这个方法，用来实现插入有序，或者LRU访问 afterNodeAccess(e); return oldValue; } } //修改数++ ++modCount; //如果当前数组的容量超过了扩容的阈值，则进行扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:1","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"get方法 //根据key值获取 public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u003cK,V\u003e getNode(int hash, Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k; //table数组不为空,且length\u003e0，且hash值和数组长度做\u0026运算得到的那个bucket不为空 if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { //如果是第一个节点，则直接返回第一个节点 if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; //开始找下一个节点 if ((e = first.next) != null) { //如果下一个节点是红黑树节点 if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); //则开始在树上找节点 do { //如果是链表节点，一直遍历链表，知道找到。 if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } //否则直接返回空 return null; } ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:4:2","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap是如何扩容的？ HashMap 中的 resize 方法主要包含两部分逻辑： 初始化数组 table，并设置阈值。 数组容量翻倍，将元素迁移到新数组。 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u003e 0) { // 第一次进来，table为null，oldCap为0，不会进入这里 if (oldCap \u003e= MAXIMUM_CAPACITY) { // 扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; // 取整型最大值(2^31-1)，这样以后就不会扩容了 return oldTab; } else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 // oldCap翻倍得到newCap oldCap \u003e= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u003c\u003c 1; // double threshold } else if (oldThr \u003e 0) // initial capacity was placed in threshold // 第一次进来，如果手动设置了初始容量initialCapacity，这里为true，则将threshold作为初始容量 newCap = oldThr; else { // zero initial threshold signifies using defaults // 如果没有手动设置initialCapacity，则设为默认值16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { // 第一次进来，这里必为true，重新计算 threshold = capacity * Load factor float ft = (float)newCap * loadFactor; newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; table = newTab; if (oldTab != null) { // 对oldTab中所有元素进行rehash。由于每次扩容是2次幂的扩展(指数组长度/桶数量扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置 for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { // 数组j位置的元素不为空，需要该位置上的所有元素进行rehash oldTab[j] = null; if (e.next == null) // 桶中只有一个元素，则直接rehash newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) // 桶中是树结构 ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order // 桶中是链表结构（JDK1.7中旧链表迁移新链表的时候，用的是头插法，如果在新表的数组索引位置相同，则链表元素会倒置；但是JDK1.8不会倒置，用的是双指针） Node\u003cK,V\u003e loHead = null, loTail = null; // low位链表，其桶位置不变，head和tail分别代表首尾指针 Node\u003cK,V\u003e hiHead = null, hiTail = null; // high位链表，其桶位于追加后的新数组中 Node\u003cK,V\u003e next; do { next = e.next; if ((e.hash \u0026 oldCap) == 0) { // 是0的话索引没变，是1的话索引变成“原索引+oldCap” if (loTail == null) loHead = e; // 总是指向头结点 else loTail.next = e; // 该操作有可能会改变原链表结构 loTail = e; // 总是指向下一个节点，直到尾节点 } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; // 原索引 } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; // 原索引+oldCap } } } } } return newTab; } HashMap 每次扩容都是建立一个新的 table 数组，长度和容量阈值都变为原来的两倍，然后把原数组元素重新映射到新数组上，具体步骤如下： 首先会判断 table 数组长度，如果大于 0 说明已被初始化过，那么按当前 table 数组长度的 2 倍进行扩容，阈值也变为原来的 2 倍 若 table 数组未被初始化过，且 threshold(阈值)大于 0 说明调用了 HashMap(initialCapacity, loadFactor) 构造方法，那么就把数组大小设为 threshold 若 table 数组未被初始化，且 threshold 为 0 说明调用 HashMap() 构造方法，那么就把数组大小设为 16，threshold 设为 16*0.75 接着需要判断如果不是第一次初始化，那么扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去，如果节点是红黑树类型的话则需要进行红黑树的拆分 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:5:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap从Java7到Java8发生了哪些变化？ JDK 7 是先对 size++ 进行检查， 如果超过阈值， 则扩容，最后把节点放入 table。 而 JDK 8 相反，先把节点放入， 放入后的 size 若超出， 则扩容 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:6:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"为什么HashMap不是线程安全的？ JDK1.7 中，由于多线程对HashMap进行扩容，调用了HashMap#transfer()，具体原因：某个线程执行过程中，被挂起，其他线程已经完成数据迁移，等CPU资源释放后被挂起的线程重新执行之前的逻辑，数据已经被改变，造成死循环、数据丢失。 JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:7:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collection体系简介 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"list Collection\u003cInteger\u003e c = new LinkedHashSet\u003c\u003e(); // IntegerList List\u003cInteger\u003e list = new ArrayList\u003c\u003e(c); // 等价于 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(); list2.addAll(c); // 等价于 List\u003cInteger\u003e list3 = new ArrayList\u003c\u003e(); for (Integer i : c) { list3.add(i); } ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:1","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Set 只是简单通过object.contains()判断添加新元素时是否重复，从而实现去重的 Set 是很低效的，这就引出了对象的 hashcode。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:2","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Java世界第⼆重要的约定 hashCode: 同⼀个对象必须始终返回相同的 hashCode 两个对象的 equals 返回 true，必须返回相同的 hashCode 两个对象不等，也可能返回相同的 hashCode ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:3","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashSet HashSet 是无序的，是最常用的 Set 实现。 可以利用 set 为 list 过滤去重： List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(2); list.add(3); list.add(4); list.add(3); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(list); LinkedHashSet 是有序的，顺序就是插入元素时的顺序。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:4","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Collections ⼯具⽅法集合 emptySet(): 等返回⼀一个⽅方便便的空集合 synchronizedCollection: 将⼀一个集合变成线程安全的 unmodifiableCollection: 将⼀一个集合变成不不可变的（也可以使⽤用Guava的Immutable） ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:8:5","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Map 体系 map 是 一个将 keys 映射到 values 的对象，键不能重复，每个键只能映射一个值，值可以重复。 keySet()返回键的集合，因为键不可重复，所以可以返回一个 set； values()返回值的集合，因为值可以重复，所以返回的是 collection。 注意：keySet()和 map背后的 keys 是同一组数据，所以二者的修改会相互影响。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"HashMap HashMap 是最常用、最高效的 Map 实现。 HashMap 的扩容，思路同样是创建更大的空间，然后把之前的数据 copy 进来。 HashMap 是多线程不安全的，可使用 ConcurrentHashMap。 Java 7 开始会采用代替链表 HashMap 和 HashSet 本质上是同一个东西： HashMap 的 key 集合（set）就是 HashSet，而 HashSet 内部其实就是个 HashMap，毕竟 HashSet 拥有的功能 HashMap 都有。 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:1","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"有序集合TreeSet/TreeMap TreeSet 可以排序（默认是自然顺序）。 HashSet、LinkedHashSet 与 TreeSet 对比： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = Arrays.asList(1000, -13, 0, -41656, 1250, 555); Set set1 = new HashSet\u003c\u003e(list); Set set2= new LinkedHashSet(list); Set set3 = new TreeSet(list); System.out.println(set1); System.out.println(set2); System.out.println(set3); } } [0, 1250, -41656, 1000, 555, -13] [1000, -13, 0, -41656, 1250, 555] [-41656, -13, 0, 555, 1000, 1250] TreeMap 同理 ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:9:2","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Guava 不要重复发明轮⼦子！尽量量使⽤用经过实战检验的类库 Lists/Sets/Maps ImmutableMap/ImmutableSet Multiset/Multimap BiMap ","date":"2021-09-11","objectID":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/:10:0","tags":["java"],"title":"Collection体系原理","uri":"https://idpeng.xyz/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"jar jar是将很多类文件打包后的一个压缩包,导入 jar 后,可以直接使用里面的类或调用其中的功能。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:1:0","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"java包的原理 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:2:0","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"传递性依赖 我们依赖的包还依赖了别的类，这种依赖是具有传递性的。 传递性依赖带来的最大的问题就是： 我们在 -classpath 后会添加项目依赖的各种各样的 jar 包； 如果两个仅仅不同版本的 jar 包被同时写进了 -classpath 参数里面； JVM 在 classpath 中寻找类文件的顺序是从前找到后的，也就是说如果有两个仅仅不同版本的 jar ：demo-1.0.jar 和 demo-2.0.jar ，哪个放在前面哪个就会被使用。 如果 demo-1.0.jar 的顺序在 demo-2.0.jar 之前，就会使用demo-1.0.jar加载的类文件，这样的话高版本的jar就会不生效。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:2:1","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven包的管理 Maven 是一个项目管理工具它包含： 一个项目对象模型 一组标准集合 一个项目生命周期 一个依赖管理系统 用来运行定义在生命周期阶段中插件目标的逻辑 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:3:0","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"maven怎么进行管理 Maven 包管理的做法是：Convention over configuration（约定优于配置原则），体现在 POM。 POM是 Maven 工程的基本工作单元，是一个 XML 文件。 该文件中包含了项目的基本信息，用于描述项目如何构建，声明项目依赖等等。 pom.xml \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ehcsp\u003c/groupId\u003e \u003cartifactId\u003efix-bug-in-integer-equals\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003ealiyunMavenMirror\u003c/id\u003e \u003cactivation\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003c/profiles\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.1\u003c/version\u003e \u003cconfiguration\u003e \u003cargLine\u003e-Dfile.encoding=UTF-8\u003c/argLine\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 引入第三方包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 里面加入了junit-jupiter-engine的jar 如果在本地仓库没有找到对应的 jar 包，Maven 就会从远程的中央仓库进行下载，然后放到本地仓库中。 Maven 中央仓库位置 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:3:1","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突及解决办法 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:4:0","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"包冲突 相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:4:1","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"解决冲突的办法 直接依赖C2 排除C1 通过Maven helper插件来解决包冲突问题 排除 \u003cdependency\u003e \u003cgroupId\u003exxx\u003c/groupId\u003e \u003cartifactId\u003exxx\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eyyy\u003c/groupId\u003e \u003cartifactId\u003eyyy\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 排除了xxx依赖中的后代yyy依赖，也可以解决包冲突的问题 ","date":"2021-09-09","objectID":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/:4:2","tags":["java"],"title":"Maven与包","uri":"https://idpeng.xyz/maven%E4%B8%8E%E5%8C%85/"},{"categories":["java知识"],"content":"git系列操作 ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:0:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"git六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor \"code --wait\" git config --global core.autocrlf input 注意： 上面的英文名和邮箱跟 GitHub 没有关系。 可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:1:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"新建代码库 # 在当前目录新建一个 Git 代码库 git init # 新建一个目录，将其初始化为 Git 代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:2:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"配置文件 # 显示当前的 Git 配置 git config --list # 编辑 Git 配置文件 git config -e [--global] ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:3:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区 git commit -m [message] # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] # 提交工作区自上次 commit 之后的变化，直接到仓库区 git commit -a # 提交时显示所有 diff 信息(推荐) git commit -v # 使用一次新的 commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 git commit --amend -m [message] # 重做上一次 commit，并包括指定文件的新变化 git commit --amend ... ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:4:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定 commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个 commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete git branch -dr ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:5:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"提交代码 git pull 提交代码到远程仓库 git push -u origin master 提交本地指定分支master代码到远程仓库 ","date":"2021-09-09","objectID":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:6:0","tags":["java"],"title":"Git本地仓库与远程仓库","uri":"https://idpeng.xyz/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["java知识"],"content":"ls命令 list 的缩写,可以查看文件权限(包括目录、文件夹、文件权限),查看目录信息。 ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cd命令 cd [目录名] 进入目录 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"pwd命令 pwd 查看当前路径 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mkdik命令 mkdir t 在当前工作目录下创建名为 t的文件夹 mkdir -p /tmp/test/t1/t 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"rm命令 rm -i *.log 删除任何 .log 文件，删除前逐一询问确认 rm -rf test 删除 test 子目录及子目录中所有档案删除，并且不用一一确认 rm -- -f* 删除以 -f 开头的文件 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"mv命令 mv test.log test1.txt 将文件 test.log 重命名为 test1.txt mv llog1.txt log2.txt log3.txt /test3 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv -i log1.txt log2.txt 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv * ../ 移动当前文件夹下的所有文件到上一级目录 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cp命令 -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"cat命令 cat filename 一次显示整个文件 cat \u003e filename 从键盘创建一个文件 cat file1 file2 \u003e file 将几个文件合并为一个文件 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:1","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"常用操作命令 Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:2","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["java知识"],"content":"which 命令 which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 ","date":"2021-09-09","objectID":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":["java"],"title":"Linux常用命令行","uri":"https://idpeng.xyz/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]