# Redis


## 对Redis 的了解？

Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、
支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。

## Redis 一般都有哪些使用场景？

**Redis 适合的场景**

* 缓存：减轻 MySQL 的查询压力，提升系统性能；
* 排行榜：利用 Redis 的 SortSet（有序集合）实现；
* Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，
这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。
* 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，
比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；

**Redis 不适合的场景**

* 数据量太大
* 数据访问频率非常低的业务

## Redis支持哪几种数据类型？

1. string：最基本的数据类型，二进制安全的字符串，最大512M。
2. list：按照添加顺序保持顺序的字符串列表。
3. set：无序的字符串集合，不存在重复的元素。
4. sorted set：已排序的字符串集合。
5. hash：key-value对的一种集合。

## Redis主要有哪些功能？

* 数据缓存功能 
* 分布式锁的功能 
* 支持数据持久化 
* 支持事务 
* 支持消息队列

## Redis 为什么这么快？

* 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速； 
* 数据结构简单，对数据操作也简单； 
* 采用单线程，避免了不必要的上下文切换和竞争条件，
也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，
不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 
* 使用多路 I/O 复用模型，非阻塞 IO。

## 什么是缓存穿透？怎么解决？

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，
这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决办法:

* 缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，
但它的过期时间会很短，最长不超过五分钟。
* 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，
从而避免了对底层存储系统的查询压力。

缓存空对象带来的问题:

* 空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间
* 缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响

## 什么是缓存雪崩？该如何解决？

如果缓存集中在一段时间内失效，所有的查询都落在数据库上，造成了缓存雪崩。

解决办法：

* 加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。
比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待； 
* 数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key，
设置不同的过期时间，让缓存失效的时间点尽量均匀； 
* 做二级缓存：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，
Cache1 缓存失效时间设置为短期，Cache2 设置为长期。 
* 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。

## 怎么保证缓存和数据库数据的一致性？

1. 设置了合理的键的过期时间
2. 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。

## Redis 持久化有几种方式？

持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
Redis 提供了两种持久化方式：`RDB（默认）` 和 `AOF`。

### RDB

RDB 是 Redis DataBase 的缩写。
按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。
即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。
核心函数：rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）两个函数。

### AOF

AOF 是 Append-only file 的缩写。
Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。
当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。
每当执行服务器（定时）任务或者函数时，flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：

* WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件； 
* SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

### RDB 和 AOF 的区别：

* AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据； 
* AOF比 RDB 更安全也更大； 
* RDB 性能比 AOF 好； 
* 如果两个都配了优先加载 AOF。

## Redis 常见性能问题和解决方案？

* Master 最好不要做任何持久化工作， 
* 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内； 
* 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…

## Redis的过期键的删除策略

Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。
Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

Redis中同时使用了惰性过期和定期过期两种过期策略。

过期策略通常有以下三种：

* 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。
* 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。
* 定期清楚：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。

## Redis如何做内存优化？

* 控制key的数量
* 缩减键值对象,降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度
* 编码优化

## Redis事务

### 什么是事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。
事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。


事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### Redis事务的三个阶段

* 事务开始 MULTI 
* 命令入队 
* 事务执行 EXEC

### 事务管理概述

* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）

### Redis事务支持隔离性吗

Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。
因此，Redis 的事务是总是带有隔离性的。

### Redis事务保证原子性吗，支持回滚吗

Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

## Redis是单线程的，如何提高多核CPU的利用率？

可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，
在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。

## 为什么要用 Redis 而不用 map/guava 做缓存?

* 缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，
最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，
每个实例都需要各自保存一份缓存，缓存不具有一致性。 
* 使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。
缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。

对比:

* Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了； 
* Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了； 
* Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里； 
* Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象； 
* Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了； 
* Redis可单独部署，多个项目之间可以共享，本地内存无法共享； 
* Redis有专门的管理工具可以查看缓存数据。

## 主从复制

1. 主从架构的核心原理

当启动一个slave node的时候，它会发送一个PSYNC命令给master node
开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，
同时还会将从客户端收到的所有写命令缓存在内存中。
RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。
然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。

2. 主从复制的断点续传

如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份

3. 无磁盘化复制

master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了

4. 过期key处理

slave不会过期key，只会等待master过期key。
如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。

## 由于主从延迟导致读取到过期数据怎么处理？

1. 通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，
同样也会做过期检测，充分发挥Redis惰性删除的策略。
这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。

2. Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，
如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。

## Redis主从架构数据会丢失吗，为什么？

有两种数据丢失的情况：

1. 异步复制导致的数据丢失:因为master -> slave的复制是异步的，
所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。
2. 脑裂导致的数据丢失: 某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，
然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。

## 哨兵模式


* 每个哨兵(Sentinel)以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。 
* 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，
则这个实例会被当前 Sentinel 标记为主观下线。 
* 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 
要以每秒一次的频率确认Master的确进入了主观下线状态。 
* 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态，
则Master会被标记为客观下线 。 
* 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 
发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 
每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 ）。 
* 若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。
若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。 
* sentinel节点会与其他sentinel节点进行“沟通”，投票选举一个sentinel节点进行故障处理，
在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。

## 常见的分布式锁有哪些解决方案？

### 基于关系型数据库，如MySQL

基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。

缺点：

* 数据库挂掉，会导致业务系统不可用
* 没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
* 只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。
没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
* 同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

### 基于Redis实现

优点：

* Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。

缺点：

* Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮； 
* key 的过期时间设置多少不明确，只能根据实际情况调整； 
* 需要自己不断去尝试获取锁，比较消耗性能。

### 基于zookeeper

优点：

* zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁，
只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。

缺点：

* 在高请求高并发下，系统疯狂的加锁释放锁，最后 zookeeper 承受不住这么大的压力可能会存在宕机的风险。




---

> 作者: hahaen  
> https://hahaen.github.io/redis/
