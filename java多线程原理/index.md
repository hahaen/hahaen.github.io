# Java多线程原理

## Java多线程原理

### 为什么需要多线程？

可以提高程序的执行性能

例如：一个人洗菜做法，和多个人一起洗菜做饭效率不一样。

### 多线程带来了什么问题，如何避免？

![多线程问题](/img/Java多线程原理/多线程问题.png)<br>

#### 线程安全问题

例如：银行存钱取件需要完整，不可出现错误。

保证线程安全需要满足两大条件：
* 原子性：一系列操作，要么全部完成，要么全部不完成，不可被分割，不会结束在中间某个环节。
* 可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

#### 上下文切换

1. 线程与 CPU 单核执行是一对一的
2. CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行，在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态
3. 线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用
4. 这就是当我们开启大量线程，系统反而更慢

解决办法

1. 减少锁等待
2. 使用合适的线程数
3. CAS 算法

#### 死锁

![死锁](/img/Java多线程原理/死锁.png)<br>

1. 线程 A 和线程 B 都拥有一份锁，而线程 A 和线程 B 恰好同时去获取对方拥有的那把锁， 
2. 导致两个线程永远无法执行，
3. 要避免死锁有一个方法即获取锁的顺序是固定的，
4. 比如只能先获取锁 X 再获取锁 Y，不允许出现相反的顺序。

### 线程的属性、状态、生命周期详解

线程可以分为5个状态：

* New(新建)
* Runnable（就绪）
* Running(运行)
* blocked(被阻塞)
* Dead(死亡)

#### New(新建)

* 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
* **Thread t1=new Thread();**

#### Runnable（就绪）

* 线程已经被启动，正在等待被分配给CPU时间片，
* 也就是说此时线程正在就绪队列中排队等候得到CPU资源。
* **t1.start();**

#### Running(运行)

* 线程获得CPU资源正在执行任务（run()方法），
* 此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，
* 线程将一直运行到结束。

#### blocked(被阻塞)

* 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。
* 正在睡眠：用sleep(long t)  方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。
* 正在等待：调用wait()方法。（调用motify()方法回到就绪状态）
* 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

#### Dead(死亡)

* 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
* 自然终止：正常运行run()方法后终止
* 异常终止：调用stop()方法让一个线程终止运行

### 什么是ThreadLocal？

每个线程自己独有的，不与其它线程共享的变量。

常用的两内部类，四个方法：

* get()方法是用来获取ThreadLocal在当前线程中保存的变量副本。 
* set()用来设置当前线程中变量的副本。 
* remove()用来移除当前线程中变量的副本。 
* initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。

### 为什么需要线程池？

#### 线程池

在Java 5之后，Java通过Executor来启动线程，比使用Thread的start方法更好，
除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免this逃逸问题。

简单的说就是把线程统一管理。

线程池优势：
1. 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 
2. 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行； 
3. 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。 
4. 提供更强大的功能，延时定时线程池。

#### Java的4种默认线程池

1. newSingleThreadExecutor <br>
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2. newFixeThreadPool <br>
创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
3. newCachedThreadPool <br>
创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
4. newScheduledThreadPool <br>
创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求

### 线程池的构造函数中的参数都是什么含义？

**ThreadPollExecutor**中的所有的构造函数最终都会调用上面这个构造函数，接下来我们来分析一下这些参数的含义：

**corePoolSize**：
* 线程池启动后，在池中保持的线程的最小数量。 
* 需要说明的是线程数量是逐步到达corePoolSize值的。 
* 例如corePoolSize被设置为10，而任务数量只有5，则线程池中最多会启动5个线程，而不是一次性地启动10个线程。

**maxinumPoolSize**： 
* 线程池中能容纳的最大线程数量， 
* 如果超出，则使用RejectedExecutionHandler拒绝策略处理。

**keepAliveTime**： 
* 线程的最大生命周期。这里的生命周期有两个约束条件： 
* 一：该参数针对的是超过corePoolSize数量的线程； 
* 二：处于非运行状态的线程。
* 例：如果corePoolSize（最小线程数）为10，maxinumPoolSize（最大线程数）为20，而此时线程池中有15个线程在运行，过了一段时间后，其中有3个线程处于等待状态的时间超过keepAliveTime指定的时间，则结束这3个线程，此时线程池中则还有12个线程正在运行。

**unit**：
* 这是keepAliveTime的时间单位
* 可以是纳秒，毫秒，秒，分钟等。

**workQueue**： 
* 任务队列。
* 当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。
* 这个任务队列是一个阻塞式的单端队列。

**newFixedThreadPool**和**newSingleThreadExector**使用的是**LinkedBlockingQueue**的无界模式。

**threadFactory**：
* 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。

**handler**：
* 拒绝任务处理器。
* 由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。

**线程的管理过程**：
* 首先创建一个线程池，
* 然后根据任务的数量逐步将线程增大到corePoolSize，
* 如果此时仍有任务增加，则放置到workQueue中，直到workQueue爆满为止，
* 然后继续增加池中的线程数量（增强处理能力），最终达到maxinumPoolSize。
* 那如果此时还有任务要增加进来，需要handler来处理，
* 或者丢弃新任务，或者拒绝新任务，或者挤占已有的任务。
* 在任务队列和线程池都饱和的情况下，一旦有线程处于等待（任务处理完毕，没有新任务）状态的时间超过keepAliveTime，则该线程终止，
* 也就是说池中的线程数量会逐渐降低，直至为corePoolSize数量为止。

**总结**

* corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程 
* maximumPoolSize: 线程池维护线程的最大线程数 
* keepAliveTime: 线程池维护线程所允许的空闲时间 
* unit: 程池维护线程所允许的空闲时间的单位 
* workQueue: 线程池所使用的缓冲队列 
* handler: 线程池对拒绝任务的处理策略


---

> 作者: hahaen  
> https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/
